%!PS-Adobe-2.0 EPSF-2.0
%%BoundingBox: 72 559 314 720
%%HiResBoundingBox: 72.025 559.770 313.339 719.998
%%Creator: dvips(k) 5.993 Copyright 2013 Radical Eye Software
%%Title: robot_control_flow.dvi
%%CreationDate: Thu Jan 30 23:10:41 2014
%%DocumentFonts: NimbusRomNo9L-Regu StandardSymL NimbusRomNo9L-ReguItal
%%+ CMSY10 NimbusRomNo9L-Medi
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -R -Ppdf -G0 robot_control_flow -D 1500 -E -o
%+ robot_control_flow.tmp.eps
%DVIPSParameters: dpi=1500
%DVIPSSource:  TeX output 2014.01.30:2310
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: alt-rule.pro 0 0
%!
% Patch by TVZ
% Makes dvips files draw rules with stroke rather than fill.
% Makes narrow rules more predictable at low resolutions
% after distilling to PDF.
% May have unknown consequences for very thick rules.
% Tested only with dvips 5.85(k).
TeXDict begin
/QV {
  gsave newpath /ruleY X /ruleX X
  Rx Ry gt
  { ruleX ruleY Ry 2 div sub moveto Rx 0 rlineto Ry }
  { ruleX Rx 2 div add ruleY moveto 0 Ry neg rlineto Rx }
  ifelse
  setlinewidth 0 setlinecap stroke grestore
} bind def
end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.17, 2013/07/08
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def

    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 

  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 801 2013-07-09 18:10:41Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 713 2012-10-16 14:25:00Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.03, 2012/10/16
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { 
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get 32 ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ rightTrim psStringwidth } bind def

%/show { rightTrim psShow } bind def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 805 2013-07-11 13:18:11Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.14, 2012/09/18.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def

/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Voß <hvoss@tug.org>
% Created the     : Sat 20 March 2004
% Last Mod        : $Date: 2010/10/02 $
% Version         : 0.62 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 692 2012-06-04 06:47:40Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-blur.pro 0 0
%%
%% This is file `pst-blur.pro',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% pst-blur.dtx  (with options: `prolog')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from pst-blur.pro.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file pst-blur.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%% $Id: pst-blur.dtx,v 2.0 2005/09/08 09:48:33 giese Exp $
%%
%% Copyright 1998-2007 Martin Giese, mgiese@risc.uni-linz.ac.at
%%                     Herbert Voss, voss@pstricks.de
%%
%% This file is under the LaTeX Project Public License
%% See CTAN archives in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-blur' is a PSTricks package for blurred shadows
%%
/tx@PstBlurDict 60 dict def
tx@PstBlurDict begin
/Iterate {
  /SegLines ED
  /ThisB ED /ThisG ED /ThisR ED
  /NextB ED /NextG ED /NextR ED
  /W 2.0 BlurRadius mul def
  /WDec W SegLines div def
  /RInc NextR ThisR sub SegLines div def
  /GInc NextG ThisG sub SegLines div def
  /BInc NextB ThisB sub SegLines div def
  /R ThisR def
  /G ThisG def
  /B ThisB def
  SegLines {
    R G B
    sqrt 3 1 roll sqrt 3 1 roll sqrt 3 1 roll
    setrgbcolor
    gsave W setlinewidth
    stroke grestore
    /W W WDec sub def
    /R R RInc add def
    /G G GInc add def
    /B B BInc add def
  } bind repeat
} def
/BlurShadow {
  Shadow
  /BlurSteps ED
  /BlurRadius ED
  dup mul /BEnd ED dup mul /GEnd ED dup mul /REnd ED
  dup mul /BBeg ED dup mul /GBeg ED dup mul /RBeg ED
  RBeg REnd add 0.5 mul /RMid ED
  GBeg GEnd add 0.5 mul /GMid ED
  BBeg BEnd add 0.5 mul /BMid ED
  /OuterSteps BlurSteps 2 div cvi def
  /InnerSteps BlurSteps OuterSteps sub def
  1 setlinejoin
  RMid GMid BMid REnd GEnd BEnd OuterSteps Iterate
  gsave RBeg sqrt GBeg sqrt BBeg sqrt setrgbcolor fill grestore
  clip
  0 setlinejoin
  RMid GMid BMid RBeg GBeg BBeg InnerSteps Iterate
} def
end

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: NimbusRomNo9L-Medi
%!PS-AdobeFont-1.0: NimbusRomNo9L-Medi 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Medium) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0.0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-Medi def
/PaintType 0 def
/WMode 0 def
/FontBBox {-168 -341 1000 960} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E178732AD0E135F772215
EA7EB7EA7641D31502E1BB9661E7B0E875AEE90400138F2AAF4A8686C73EAA44
E5CAB467770A3D12E9807BAC97B24A8EFB0E276760F4F51EC7123C43BC6F8DCF
9A2F496A9172813FB461FD870763306B45670653A9780FF409B734CFA74C12CD
150B03344295918C4ED893FB620A9499404B83C71152BF2F2DBF769000D116D5
EE264C016EE3E1241018F59544CCE53E5AEC124CF6C59A4D7D7D511ECC9AFD49
6608ADDD237358D7CF8B4D1C5BD1158CDF2D6469D9BD6E6D9762ECF34D1C3C27
5F69900E0D12AF9B21F153585742E999870BEE3DFF6309CD82968EBB40D9C269
CD4306654AAB6734151132DE4194072485FD082FBB6DFCB3FDFF9E1FC88D9483
8AA64B5825293978C70C9EC095B18352BFDC34B4BE9C939384E3281BCC6B1808
A6B61EC4E47BB6AC14B105FFA7ED6AE99A1CA0B360D1A5C24E0FBB55C66F5811
A5CD0625654654651979A8C4C3612054181CD300CD42D1D9CAAA589118D6C7CD
5EA8A9A0C639D5539430D40318F4B739DA281ABF2BE2765D44F45B218BB192E1
9EFBDDF7777E8730FA7DC0651BCD5D68EB743C51D9CED55403021D45F77CAB5E
7E892B3D1F875DA86C030A2387487DBAC8795749E849EC93439C9E22EB20D11D
07DA0F09EE9356D55B8D0D8555F1B0EC98C72863B376D3436E10DE2FB1AB9453
DADA019DCB64F6D059AB3A95B28B94435004C9A8BD3FB80E2B9DE0E330D03622
3AD965B4283E6DC880A2130185CDABC053C52693CE3F50557F524D7CCA9BE05B
FF9597ADF5D1C432C00C0B0D8EC2CA8436685B4BF3E2105B89FA6CC787B77637
248796C2F43872B3BFC8011159C22EDB7149AD8932360A88A223CC638BED257E
04908032ADA750F17279F7331189C322CB5ED9B66E502945BEB1EC68B1C7BCC0
2322EFD669C229B28CE1D0CBC0005FF967D0A4383E29538AFA13D41D484D739E
487D497DEAD8F661847A5D82D77D91219ACF666E565292384728E58E1A489054
8C3E34B413A6A550C499218E7FCF43694CBEAD016119CE85515F5EDAE3CD483B
A0F32743E7A189708AF0CB6FBAB22AC8F23604FFECE038C838472CA40ADEBF08
47AB1D450E07F9D51828D25DDCA679E3FAE54634A37AE1A5A778365C5A2C8A27
64085AC775AC132CCF27CA164C4721F67B63D52E388B17122F15E5DF391674CC
B6C9EDE307D79E390068970FE0AB210337558544E8CA59BD85F3105692D9EC8C
656E64E8E61F9228F16CF415B773153D9690DC14429CA42BD8B17E3B0373B719
561D54AC82CE6CE436CB8730DD1DCD09A93E9F4A379DA75BB9DEAE0AABA204B9
909414BC316395231A624761FA8430E43AA339F16CF415B773153D9615D0738E
35DAD8E609366A2DD32C0F4AC6CE4AAFE63836A1EC53E443C21248A4D19B97CB
47F87BB44B486BE4835A8BB915293C733E90B60F0DB14D360264AA4469FD8D65
3E8DA5BB8BF813CB9DB27CB44AA47AA0D4E64824045C31014F7CE5B394E5C468
943C93A222AD65F8083BECEDFB1567439AF718D3B7B02416DF5DECABA4048B8F
FB0F430342E9A29FFF81E59CF308A0BA859BE0BEAD979398F26FD1680CC331C7
EDD3E4B4C930798AEA94605EF6283222A4FE45E411657A64143555648F92650A
286628FE70E07414F411C092F1DDB6F6D26CC32D638BBDACC51CF22379D24C2A
0780333AB3C837190DDD5250200A157151F7625E63296E325E2C36D7A94F975B
C8E57910FE940125A576E4B9BBD385775342FFEC6044F952A4EF7713EFC7017A
63899555D5D6078DA0D6C0E48F1D065844515CC08B55C960DACA6E1C7A710277
9082F718B9B616E07B5DFC25F6092D26E107FE7B8A181D56098BBF17532C933C
63DFD34E91521DC79059F70027162B35F7B2C660A6C778D18863F578DB8121C2
49FADFFB69F2296D9F724349DB48BC38692995EE0690A278917A0BE8BF278B61
2A84F1B06BE4473D026CDC9CC58B25A709172FB03C68D6DF1D3105021F0B0AD9
71DDAA362182293B730B9880B9B9276706EC7C748A40418CD85FD323D46131B9
284B3C99F7EB4E1D1C5ECFA2D925E13BD7D67620B5D4DD4C219321E41EA5FA84
6C05226796D86CF4415C5B72E4AF5A7A1EB68C7AAFD6A174B76EC9B4E80F6AAB
432DC443DC03930F36B48779449BAC308C6F43FE6CAAE25BFE73E22391AD1D0D
EC1DD4E91AED7FE13BE59C17B77AE4C33494AD1E41A896F478DAC8B747F60474
884369F48F724023F029A76848503FC039FEB875DA3B184CCB17539CAF6DB91B
F6FA48E94D48C1EC30A31507232339F3FCD771914933CABF613F0F9FA3E2038D
427561EAC1CF4EC54D29A0B9DBBAF10B53AAAE65D725D70571F948225DE8A566
CD611F999BA08C604C3A5AF77E9C396B60AC5143932D62BD7454D7C4A19130F5
0648FFE450E1CD2F0FE4EFD68797E34E14CAE61E62F245D9E49B3A42967A84A2
B04CC19B94A56D28EB6BA0612FF316DB41855733B0CEBAFBF72CBD3CE79A0E99
761E066F7FCA3E57C46F3F924AD3D83219C52D296CC34514D95C71475C1F8EB9
59566A758566F0A51F980F96B20047C27BCC7AE4EED9C98A5C5AB82ED4578CE6
B795C11B84F702A102B347FEF08A6FCBE524ABF617176B028A8325608946AAC9
0B2AB081EEFA2386EA3FD2E3D8B66473C74888BB0C5CE966D64201F37996DB1B
6A97E165EADC6CE23BD6CB9700745AF46170A19F685F1F909AEB88CDC05F7CEB
39E1C7E54887F3005A83CB86194698E16369EAF90990FC04F4D36D11B43D8560
1ED4EFFB48E83B9BABAFFDF4A50900C3F2BC50B51C7F0AA44BC1842D76C4AB68
473467C39ECB6110398F577234A79D34F58AD6DDFFBC47882DE78A1A84FDE32A
EBF03AC98FC2FA29D1706F0475470430F4F6665982C069EFEE0EEA415AC49C82
B8F6D7252103B3BC5F55E235A90201A826568CF2C21EE1C3E0F2FA7E2ADC185C
844E9F0246F8CA03BA84311B1C9EB101B01D5D3349B6F868364FA6DEBEFB2803
85D2F01C2D25BCA2B4E479414E699B812685A5890DC3FD92D04ABDE47EFEC71E
4973F629B392CE3475109E26040350FD4F8AADCD73CB08A376CB8E95E4248C4A
15C5107390CC3E2D2BBEB1220329E86A68680D1F9DABDEC5B5A6EAE517CDE929
F6E5DF7E097E47D26E7AB30037FBDDB04154DD1C27164288A1ABA66A60E06D85
964FB3F945E0A8B3D0BA3DB62D680AE9DF1C22D1E59FA34EA77677BC93550072
2066F025C1104FFC325D2C11FDA4C818B0A3812B714D9025814369FE71C394AE
BBBDC532662182AF7ACBE0F0F8390F9CC2E0FBCD87927B6D15C0293B8F417DA7
D574D83165C98E4FCD934CD31F2397BD6B4EA4764C0C9CBF8588E301FED31011
F1756B58168F9FFB572D787B2FFE01BC07C04BE94C9038E62266525677BF0312
60CEFBADE0741094C8D765B3FA6EFFF40361ECC45C4D38BE8911C50F46854FD6
54985D1DED29E1B7ACB16EBB96A0A60B69DAD34413B317E6F789048BC0373F3D
FEC0732A013ED26C5C8E686F3F263BC002C8884F38F3BB6E09768DA6333695FA
6890A620DD863BD5364A28DE4283D9697BAD9CAFD320D8F1E60750FC8FA17A96
860BDD648B81360055EBA91893597A866F289B75B6C623DDC0E21644DC6666BB
2350231579E82A4A8EEDED2E000BF868764C4627CB1675AD8F922E6C8CB66907
4E47393EBAD5A0A3271C6D709209D8E53BECCB5A4D2443EB3A0638E2C57780F9
81545E85525FE962D2E1CB05A36BDFB777319C3433A852EB0B3E5A1B0528FA9F
8BCF9EB99C71F12B4E8236238980D919C3D1C16788940C2E9AF911C842F9C4C0
39F8EA5B13A3A9554E4F789CFE36DE0E519C84DC7C2404ABCAED0FAC8C87F13F
130AEC6232692DD1F7BCB905A78FDFD2C31E91F4374CD9CC070687AEA01E611D
2A9C5C0AB25486AC71014AF1EC01E5C03C65A92958D22B63F541A5C8997C5A7C
F6757314F8DC4749DC919D6C50524CDA3E22965E2FA5A0FC823D96760214DA5B
34886FB2BB54D96CD87A596A9B03D40585C0AB2F5ACE792F05368499B19687E5
0E3606C3D7F3AA612E0FDDA6ED16BF1A0A0ECAA2D7D47C9B86BE83EB86DAF47C
A940E4F783A6ACB249FDE0997DCD95A3039B8BEF2C02DE44649AF6BBFBFA16FF
4F0AAE3D8E7009B621DAB32FFAA0E9DFF04355E881475EEC3229D142BDF08C13
56CE769F44089B98FD9024AAC0B8B6A0233AEADD6CE28DDFA18C6686EA3A2C78
ACE8880539ABB8471C676E74152BB406501AFF79B091AAEEB98200884678144C
00E7BBD6E727EA7E68BE01221C0A4F3A56E60B029FFB3DA6371217652A69BD59
860E4F0840717AD8CF0C88283550C38B54EC106B3DAAA61EC61F1917E29B9244
05B15A39141AAF7861E3174D25DA268200657965D92A6B6AA4BB9B272B07FEE0
C28522DAAFFFC84B3AF701CF1AB4DDF4392B7F946CC5FDF052322E21FC75A175
250DE6FB69CD1F3FACD8ADD658D704F64C52A77F03BE07CB52B6321F7F40DB4C
D0F93313FBD1B05302F5FE7082DFC0776D80580136C9BA75207C66D0B692FE7C
9CEED9A54EE6607CA1540AEE9BD2F314B4595C18B7A2C0EF1F5A33B8BE57F382
3DD56FCABEAAA6D87458CCF25F198AA55DBC4F8AFB269312B765020265AA13BF
C463A010261430AD895A1755930C12D26D2489C6239BA362E5A3B9F67D361BF4
7CEAB4B517B03410E59E6C7C4ACBD209E5F18DF65430114AB73225714419B8C9
88456CCC24B81FAD59AD71A3EA6BC538E1E3C2855DC776AE87C783986BE30180
3D8541D36F88A53B5D5FCE9161F188077CC0963A83396A250BA2BC0A762BACDB
4317A096B045AEB594CCFE0E61F523067B925D0A9226ABDCDA689F202F60831F
7B4783DBA1C4DD0BDF076B0AEAD03AB485F43DD669E9F6D78F7F3A39C4F4EFEA
FAABF563ECB5AF94AE080ED52B69B3110D7BFC42CF2B702F18BB64334BCB4012
96D4E8B37B8DC836A7FFB12F2C8EA3190C0BB917E3E51952CEE11CCA4B16D780
8F174524917B7565B6BD54648CA667ECA9FE1DCB131C50C2EF9F42EBB5A87769
8C64EFDCCE17E4507D230E43171BDD9F2B01647409D81F7B56BCD2F98C421464
6136D4263CBE05834B4102E14D08869368BCA726BA3ECAA352DA3A258C000CE9
1639822A328B3232F420407A2DC71D0FFE7302221C30C5A65B58377E32B298B8
40991C405463D6A09A1161851F3B42547F2E2696386D99CE937A447BDB6911F8
FB5AB09BDBA7F0E23C8F5E5270D039B409D504203A458D31787CABD0FB7DA4F5
18B81FADA81814332B622EB79162B7575B1CE1913A21F06F84ACB4D05C25DBF1
5520A388C1375D3328E0CBE8D4C5FE42198028A9496278C17CBA903CFE41A030
BAED3FD73752C693BB69DD3098564D01A42E030F2B4381AA5142F8B8F8FB9EA3
0D23494FB68DD23B6ADAC40C00E20BDEC7FCD299F74EFCF2FD128855C01117E4
5F49AFB2D3E936B548CD78AA6A6FCF0E5BC0640A870F02D282D91027980B70C1
F429DE136CB5150B1723BEB74CD0B46A97C5885683648C4DA5BC7D20D3898CF8
4E9B8D45F48D987D3E76BC13E223E102DF145500D77A97A8BF4FE267077E1564
86DAD7B0DEB55FD288A652BD298B1DE626D4929B01624287389F47DEDDA4A13D
E824ACBE4C7AA02DB29B7C4085CA1B13646EA457E1257F1CD0EB862449ADB868
FBD8EE4955A72E177F1F402BA58516C2F8C1036555718F8587C18043785D1F29
3600010EA868FA253565B50BD7787BDA37FEB4236172A737695B1BDA6E46628B
340A2C280B99D60757CB814F513009C4F8EA0E7C610D9C6FF13D76FA47E1D2A4
777FE0F2A4F6CD518EB67C27F9A9F4E5EDAABB95B187A4643893395C4BB175F1
BBD94773C85056C324BAA2C7919C7E116629E963F00FB88D12C5D6689449C6D9
74A97D5AEA4652625C005977FC252CC99529D7F6B88EA20514F3453A08F1898F
30FB9588358E5EAA28B66BCCFC7855461372B4CF5400F4B7BCF0DDEBA619237D
25D5FC737A8F67AC79678830CA6BED68B752F2CC1347B4D4AD31E7B1B93CB1A2
DB181104E45B6CD6FC02193B8E72415E9CFD2C39F71ECC65F1300CC25212F442
D9F3A4760004D1BBBF9DB45283B2F5631D37BDA456C62369484B1011EA7C2B87
226EE6A4C6526AE5DA40973DB92538098BD30B3B2BEA74A8DAF08731634F35CB
33EBB3DE636A8E4EB10E500A144A602FAE78B968D6A4ED5BFD704003D6109121
880DA9C89FECEC969068C0467495F08A80C6EA83D4D635B305BA4C153BF2E860
6E686237B6BA413F846A887BD1B3B89EEF73565F3D0D2D18A5B66AC6349E6D09
199BA12884737714C5FF1616348AF0F9B4879A99BCAF708E326D070B8A72B4B3
BE25B94E0765F244704AE2B065259EE821CAAD682B251DF56292A54E3AD3F267
F646450EB7DB5799E8120D2A4862425FBE0476F65EA74CB0A90A62A05E0E6853
A89537F386FD3FA76D1FBCE0045C8F147537B7C2221103C664299C9D00EBD38F
0DB5BD23B4507496C95A57D76C2C39A36960499A6FF390554547263F60381EED
4B36B3D0F2C4A75427FE41E99CDDEA8DA5B4E516AC39935DA37F4B3EE9F0687B
6F424CC20A98FBB384FA3452AAAE1AF13B492FE734756120D581E9F3F68DC6F4
4D503C233895B9C85CB16F645723D143A8D4D74D8FE6C0F77B08D4232C678067
511CCEDD11F7C39B765BB942E979AAA1DE3496DAA9C6F23D76FA47E1D2A4777F
E0F2A4F6CD518EB67C27F9AC01821DD89F3FA8506F268809EDFDDC647A3C41FD
3F4F720BBD39451AD0062C6D1CEE3D463FB5F6588F7623A5C457F254438F2343
03E15D8F7E4DE009307129C04632753C65D91E8B28382FDCEEAA89A3E0A6CD42
9A2A5439412FF4F71DC5AA368E0EA45AE3A0C9A76C320DDC31F02790EBDF9062
4BB22393DDB90DF1D8545651EA776AC18E75E8F3C861CB90E032EDBB29432AB3
533DCA6D5340527C15455276ED0FCD4F407B558A3481CF70EB9B4BB922A45593
BFF01FB5C81D72064472CDE27EB2A07ED2CA6897FE1C5CF874A19C1CA420C5E4
2DC48928E3A101941D80BCF9CA2EC1C744D756434072ABED45EEAF36035D6F74
D21C2C5594F8D50CE1C9C1587DF29768E6F31E033C64C279F334CBFF91A55B96
627CB983955FAFEAE6603006151C3AE0604FA082D363D9054731A46B573A0B7C
0AA64173DB6D0F347EAC53278149C69691A7FE1C90D9FE3A616FACD79B8A0439
F0DCEB6DEDD856EC44C479A6FAC999D0BE86412A7EB0A992E3D85A530527C2FF
533D59587EA2BD6EDA120F1EAB008AEA3E91A9AF557C980285F83B805E4EEBF5
9A5181AD8AB3B48C4FFD3DD2004660BE13501DA6864A392EAA1188ABD285C548
22AEB2A27450B81A42F735F970E65FE925C3A8FAA8B8585A46F08E5652940EFF
E0C90CD1C22D8CE82346361F57163AE79ED3FB45F38C393BEF41B884B715876E
3895992E573F120A0BFAF3B6B2AABFF1EB1232652F0B1F0FEEEA7EE2DD2AE77F
2751852BDA594FF5DAA9DA0BADC97142CAA3B45C8B99B7CF3B97EE41D670E56A
DC97A8132C58E11BF53FDF5D6C20FB02D4D633F61678DBFC473FA3FC408EC625
E310DA8CAC54C44C77AD577622457DA9E456A76752028FDFEB9A48DA79BE461D
A47CDCEA3E0344D494721CD9553F5447B67C40AAE326068AF430817085A1F62F
517167F9293FC037AC65EC2E15CA2833790215E318618B9F030BA283B3384F8A
D84C63B736C82A2FF5456020104D2A9B99F31A52E82ED5018810B2930F4E2DD8
0DF3CF1CCFAFD185C382935A00D82E1389C810291F79D482EF4E2385E6C9FD69
EC9AC032AFF5AC41FC836FBB96FFC711AA17A9E1CBA3D8443CF443C9161E7E06
2175D2DB60ABAC3953E9BAF0662B93B2096355213ED8F8D75E43A8811AA7264C
F2F6813E4A1B5693848E355E8EC005A663F274FC017CED03A2C257A8AC234E9E
9616F1ED935B4BFB66BC6C6833EE408E68A4F47012574E82815D8D90063C9CE5
ABE9426C77CF1D8B3252F073A0A38920712083C208DA889BC2135E60D62539
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMSY10
%!PS-AdobeFont-1.0: CMSY10 003.002
%%Title: CMSY10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMSY10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMSY10 known{/CMSY10 findfont dup/UniqueID known{dup
/UniqueID get 5096651 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMSY10 def
/FontBBox {-29 -960 1116 775 }readonly def
/UniqueID 5096651 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMSY10.) readonly def
/FullName (CMSY10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 20 /lessequal put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CD06DFE1BE899059C588357426D7A0
7B684C079A47D271426064AD18CB9750D8A986D1D67C1B2AEEF8CE785CC19C81
DE96489F740045C5E342F02DA1C9F9F3C167651E646F1A67CF379789E311EF91
511D0F605B045B279357D6FC8537C233E7AEE6A4FDBE73E75A39EB206D20A6F6
1021961B748D419EBEEB028B592124E174CA595C108E12725B9875544955CFFD
028B698EF742BC8C19F979E35B8E99CADDDDC89CC6C59733F2A24BC3AF36AD86
1319147A4A219ECB92D0D9F6228B51A97C29547000FCC8A581BE543D73F1FED4
3D08C53693138003C01E1D216B185179E1856E2A05AA6C66AABB68B7E4409021
91AA9D8E4C5FBBDA55F1BB6BC679EABA06BE9795DB920A6343CE934B04D75DF2
E0C30B8FD2E475FE0D66D4AA65821864C7DD6AC9939A04094EEA832EAD33DB7A
11EE8D595FB0E543D0E80D31D584B97879B3C7B4A85CC6358A41342D70AD0B97
C14123421FE8A7D131FB0D03900B392FDA0ABAFC25E946D2251F150EC595E857
D17AE424DB76B431366086F377B2A0EEFD3909E3FA35E51886FC318989C1EF20
B6F5990F1D39C22127F0A47BC8461F3AFDF87D9BDA4B6C1D1CFD7513F1E3C3D3
93BEF764AA832316343F9FE869A720E4AA87AE76FA87A833BBC5892DE05B867F
10FA225E233BCFA9BB51F46A6DF22ADCEACC01C3CD1F54C9AEFA25E92EFAC00D
7E2BA427C25483BA42A199F4D2E43DFCE79A7156F7417ACF78E41FCA91E6C9EF
B933450D851B73A6AB6AEA7EE4C710CB5C14270D1674FA334686653793FCB31B
491E870D3C2BC654D2C1DE463EC9BA29D7371AA1078800EF93D3F66263A2EBBB
F5723697BF7448BD0D2E301544BECF497FD475B85DFEF52AF4F8F8BE445CABE6
019318806D10C5952157FF8F8286C1EE701545C8F60EFA854EAE66835A2046A6
915D395F1E0366EFE0C0391583FE001FF16D82A2E2DA5F57754A2C6F69306E36
356ECF8EFC3F1188AD6FCD2427E0580C97A5B69B4E0E09B85EEDE142F5ADD2F0
5DE51D6DB72B127412A0D57106C19CA493048A4F815129ABE767D51715B1515D
9C21067CB5BC88741B7298C83EAE36A866DFA87D8981F179B1C31292F56BBB64
3C430779468AAF07C8A8B4934E1E775FE3F35186BD1FA6EE3689C1C750678AF1
FBF9B23195A124C5C991FE670AC0C86FD39D2B07B9A319E74EFD498B45820252
720ECDF7294F7B0B137CEB86D33BFCEB8606985A3260FD669E461C8BE94216C5
D434FD8854F44EE66E5A289A9F9E32BC36AF645D53F96652602BAED418C8D726
BD04A1B4617551FE4DEF54083D414F7DCE004E6BB2DC9C2EF7CE232B254BA2C5
7DCBD36C2072ED46FF711F121A701E2284BF1B718B3164382B8F453D68FA0377
DFE106503B8401D4DB87F5402A3AC9A442FA060B0610A9524D530C7157C26B56
AC970FCC1D5655FFFFA39246E6420CF97D08ADFB7B05822679BD40C638DDF0E7
A97BFE8918B611A145AC965C203F1428812F9D340AF499B3A915B22BE798594E
0F520109FC81E452180AE45B170FF999C5FC2761C6CECD8742A5A6FC97F16743
AD4EFCC6572A6D3F3E4E330C5CB2FF6FEA48A5B64DD3DBE943BD9918D4A18E18
CBCF598AEFBB6AB3CD2CBC9BFD6099272F6543F3E532E0E21E614BD2880B1023
0AC234CB705827BF016DB84E00E8C255FDEFA0101A842929540B7B4AA8A089BD
5EFF05B72356B6BC3727817823B5CDBB1B963103000D7F2A4E2A1472FC3E614B
5CBCB6D6D784023173DEFEBFA8F9ED87EC1A0A9EE98CA59CFC964CF943DC683F
E9E00DA718C4425A705A69D99988EC6F152525C790912C2E46A2381A569424AB
54DF4798BC2D7E7A361E7991641D4B756CE2A7FF4A2848927092C59C2C4B8809
E13AB84FB6B111E680D7FB9F2FFC2C5C66B0B501E4447C2E46C10E2F6124476F
A140C404CFE2DC9E0199BF61E035CEB481D438139A9630934E541D261FFD2906
4CAD99E20655FA746AFB81EDBB5601F5FD6B1D6832A01D585E2C55053F6A7378
4DAACCAC7608DBDADAAE732D66B3E7F87E79756337C1A961E53A4651BE7C77F4
038B89C87F650C54A2A90EB7F1D525BB353F33318551EE8D84A6A83C718EA5A4
B2AC0F7306B1E095819B87015A90CA3ED739B09061782C28CDB36BA4BD5E5308
5CBB70414E4112193DAC4A1FA30996327230D1E021F3CD8115E12D239D93FFDC
B645910EB29E40D830E7BAF2DB255FD7C4E776557BB38157917D993EAC245837
A3B515147043574157B8342D829C7228CCEA843ABC89D1785A9672A5923FC4CD
2F3FF27E6FCACF84E2D3136CA2C0FD3EF1EE7354CD04C38B5FB874553646ED2D
CEDF7E362EADD04B18051F20A8FB0DE18E152385B9D05F98A3A7EF177824E246
455ABE69E2F700EB78185CCFC07E3B4C6FA301112528D977367D30D0D5D59EDE
FAEB706DDC970A9E296236C725B2B55B09B9C336B8E23CBA5FB8692D56F33B03
16294E5FC7FAA42E96395A57CE51CA8DDD77442F142E2E576B778373FB31C81C
16840BB422CA827E30A81829648BDF1CA36700EA32AD888D097C1FE0A05B2D9F
483AEE40269DF09AF0D1AD3DF80C45DDC59C2A03FBB661C79B87853737C6D352
67626B657321B16198DBD6DB98A092F17878AE4698121E1006E53D6F9B0A3BE2
3FB68828EF854A0CDBAA68B37ABCA6AD4A3D809AAF0BAB1697A81FE59C98C472
1E33CD70A75A22C249DD11D76C2575ED3370A25892A16D2FD569CDA70C130770
93F493C7D47D6F9A5424A7A542BAD726BFC3AB225DCEBBE6AC4BE006F8C7C0EA
051424B08305BF2D951AB2986AAFEA04E078CA79B399585BFF0F1ADCED02E15B
8765EB6BF6A8E4D0901EFF2C3AA104924EAD9637A35D877E0C51A3C37DA78CD4
8643C8CE6DCDDE3F116A6C2390F948E5371BEB5AD2E87B41C5F01FB5C196C436
6E256A88D082E3F46E4EFFBF605B2EFF1E9D9AD5EE4DDC323A137CD9451EDEE0
06F7D82898D71FAF2362C0FCF1F726F97F820305B7CE20728CA08C63575083A7
84BA28B7DE2B916432475510E274C12FFD1660A717F51DACFDF0A102D85224E0
D6DB607BB72569ABB8A7BC6A10354CBBC01732EFE35B72062DF269CB25EA3DE6
DC603B04C90C5912D2C38D7A5ACDCDD3F6F116D884F0D8C528F69D5D47BA20DB
0A9E585C7D8CC3C324FE8A1DF150279F7E8FB43BDB720E624E5E9918032C02CD
8020636AE5C38DA2484B7F4B34163E0D0A561B43B80E97746DC05C871AB620EC
C5D47101ECED4A7E25F291184BEF8B80024AA7BB456C1B83A907652B331DEA34
754226C39C6889EBEEFDAD081E01EF8FE47751987667836FDE4C8BB8A3FD4406
1E643B4EA37BD370734D1A2DB17C2F4B74B4ED75098B433601F75A88C9A37A05
CCB157EF6E32023BFA33973F3E655A4D58289136996FCFA61EEABD70791B6523
1FF5DE71AB8A17038923118A5EED8D59C4C58D246FFA9BB26472346B40C8741F
153D19CAFF20DD2A86C6DB89154A630FB1761929FC3F0448EE2F089C1C953E02
905BA8DE75D101A982A611056C4B237596C10951DD98BAB838B742D3CF7DE718
617DB72E5268583223E37E029D1C8FD3F1D21690151F76B76C52C725CA135CA2
8666553E863CE188BFC9B99AF56AC2DB5BFEBEB12FB563D00244EB89E478657A
98AF2E1223C1ABC25A4500E8119B86EB3C26B8A2F3505A3E5610F89B7C34E278
53FA0A54A7F46D84A35EFEC36AE660A9E3C37EE3864106702DE5AF6C45ABF64B
888A4A51323138CE77DB935576FE6B4824B6942DF80625098CE1B5B32B234F1D
052A9D6039697118A9D793793775D8729D8574A2E74D7109C7B7E23BC5E2E87A
CA8E019203952A4892544E1AD3D4EDD22971611358AB230E9A2ABDF00A288501
A01B67C42B33F6B78C39562DB50F4663B922D9BE0D8A150311AE44B83C1F129F
07337323E9A23211EE58E16043E127C6F9574019179F5635648A011266677B56
B5D0201A4E1470B952A1579B57AB2329CD4C615395023C653F784D36B5EE3672
10D191F29EA508CE84763CA4CE7C2C5229E38E241255A5CABCD6C7CBAED901A2
CA53B5E24111921CDDF83578D33D463D70EDACA0E470D8F592303FB6BFD68B4D
3F3BE2D7C5EC8BBF10C90111A33E205F2649B56E8443F6FAA6C721C66575AE12
D4C40F1F46CF9E9DA675AB5D5840D938780CD9E4AD6736ECBEB6A4397613586F
849B51048AC5F9405E03E14540A5E5582F61CDCDB57EDDF95A8C6705F433EE16
648F098C03DED8A2AD94AE3DE202D629B9422ABB031318D48F2C85F9DBFA17BE
84708AA3B6C9F81F4508F7A5CB7B6646AB8722ECF817877B77D473F577556DAA
2BA0ABACFCF5DEA7498C47328E873019A956FBB250FD9D8885D21D368FA70CBD
2709D2DA44EE7A9869963EAB48789541906DE49FAE785ECE1F18A22C7E7ED204
9768896B78E9EB7A2BD6EEC1B26083940656ECD689D92942CC8AF05CBF82AED0
B45A7DF4DD7AA6526FB597322560B9ED3087A65B5EEF1371C328A021411BFE3B
D9B5088B2F1AAE381FFED52D2D1E02CD0DA78683E3B06171CBE94BE9760005D7
135893D7CC2DB097F6AC664D9594CF1C650F84DA80D2EDE04802DBA33CE3DAFE
EB7A37E8AEFA4FDA6252FF21E8673DD98E67124D5DBC7BACF361E57077B71939
C1D1FB923E4E35C075CD1BCBE0E80DAEA1320D55B43EAB45D9B26C366B278782
7519FDC482D98839BF0DF2E7C3A56A1C1A3FC0E57A75CA414F6536C1FE8EB7A0
4ADFEE3BEDA0F53BE8CF5F64230784A797133E8CD46BCCB3BF38BCE38A73CCE2
9E073ADE792F7128231DDD1F63E6156ADB2609C200837C2E8A2D93D2A7BC9171
050C709A71E44E32B1B03C92EB5CF1D3BAB1C38E027DC4ED9AED633D98CD7486
3F773ACF8AE332631CF2ABE6D606607593FE862ADE31803964E3F4DC3CE3A271
C76BDD95C87CDB3B87BC26FC7A16D567EEC62E6FF0D471B4853DB8A94D4CACF8
843824F818083F10E88D52FC4253E8203292CB40F1414AE7E51DD7347007C342
CD70E8E9F2D2A13D71213B841DDEAAB208AD9EA644591C15DEB084165F9DF24B
B91D3BBEEC2E34E38EF16A0C3F00700A7BDCBBFED2EC0D09601AD6538288DB50
3478B051B5E16B604A0341FE621A58718D960D699D3FAD284310DCF54EB13175
19A75A539EE98E804AEA24689D3540F0F12951A3C01FACCE9A7BAF4D0DAFA946
FF65A4D2A4C39969607272C6886F44E90ABE27CA3A1F12A29D9B32E60E8E34F0
17C5FE43D0E69A99A922D98909B2BBCD145E59A5E7F5426B3988F73B09A525F6
8BD4915663C1301323180E760BE81CB874B020FDA3AE63340E4261E4F3E4949B
CC0966BDC4426190BE9F5D77F76A72AD925662E5FE1CEF9CCAB68F0BD33DA003
F11EB91AC4502FBD6AE48DA0F9D07C35B96B103E379B8A83A05FE728F1716194
1F650F75BEBADB2E3810388F3E2DC7B19F1BA9E32925F2FD9F19F4E8701F3E4E
4069125D7C401144740691E7A460021A47B1E27997FC1DDABEC5BD0EE0B20194
2D579C7D6727AA124083242BDA46D8E116E2751C5F298851A62B60AEBE82A929
9B9F2492BA35690D1EFD16215B8EF14E7A3803B93C28FA41D971B05B6AF3B593
E74AD1E68A5FCE12A86E63B78BFEA87D3949FD164F12277A4688BE96356791CB
8671C49365608F3EDECC109321AF92B4C29CAF073DA3A7D73E913D0D83FAC5EB
BD884D4C686056404DAAAD6F82F94F803FA1FB0DD8908D1DF08FB87A8BB83027
04DE0CBB1C6FEB6B517FBD7CF065120079E608CE41893C2BC96A347826CCDFD5
C69E161217F2127A59F1A6F22037641613F191F22D5B4CDCBCC2EE5615623404
ABA7BE6C5FE475481615B2AC1A2412E54688DD21E44CC9AF5F16E634AFCA389C
4D740B7B51BB141BFAD1080E7C726C1606A28ED492E6BDE9F800EFACD1513909
84E98CEB6A0B7A2A6F3E1D1DCC3B2552795E0932673E59ECC56DDD37A1D52BA6
C3F0E905978AB568941A163F4CE3AAB5C5B16F86016EC47BA6F3F7AAAA77C3B6
09C8C3ABDB6D514A76ECD37C37AA88B5860630B3406B494F7725975596F84777
D9CF48686EC9C5DBCC1D78513F591C7C10AB9D153B3D41426B7BF668B0D04503
56BCB686258462C1DC61095724B9F3312316262FD7C1AEC6E54DE7E5A7BD8EFF
035299B8FD8A4A7B0F51404F4A760F4D8B4C0FB7A32FA4B2383AB6E9C78FDEDB
FE6A5788D38A6701B123630C2A6D820A684166FBBC83DB17069494FBD411B333
CB37E2491C5BD035A33867A6D3A3D420CC31ACF43AA07182CAAE67E40EC63663
B678F71D4C6E0EC3A0AAF904CD3AA66E0DE5E3CDE049E94249B39A1C06E3CE9A
F974B2484BB2CDA14282B9511E505B3C89F9C802218AE40D1A7541335C5736DD
CD565D4B9F4CC78F3A393737EDB4FBD0DA299E21CCFEBA5478EEF013F0552A8B
0BB11FF46CCDB784E8BDCF730A16363E66572049E42C695886EAB42A9AD9094C
B635DF4B5B9BD9B9AE8455DFA3EEFC77653190F9A8B1E93B7281C2A21EA7DDA9
33484745BDF7E3DD63C7AC66C286C9A5A698A5E4D7A91710B7FF943FB23609B6
4B442F83CB795788FAB5E9CF3F75D5487DA26170E4561C7941C910B088C3B86D
F844B0F340CF82786A3FCF347048463EBD2006281A816627065DDA6CD4D3AC5E
2024BC96C7D896381BBB567951E7A1F29D4E95351298B000D29E5F3D0448CB5A
CFDAE1BADE9403B90371C3A07D208948AFA022A69C519434B6813086ADF518D5
88E0B92072A44BA1B3EBB630A13B7AB90992E85B6D67361C8D96F3E0D826FF37
17B67E4B1EB7BADFD98D7F4FD17BECE740ADF13C141EBF0A91CB105DABB32FE0
55086D56A0D358841D15FD349E6B95512E4EDF4C430216FF85C2ABE995E4B40A
A6044CC8820AD885C07E052B3F91C2E9A1D163BFFD210F7BE95B923E2500DB50
2075106DB541C267BD450B25B670CE80BCD068D4DBFF2D82634175B61FBD3BC3
406131F44C7D6F18D375D1F2270829DDF29DC14DBB58A30AC193245D18DE91F8
AB88AB548D8138605BB5A50073295534E314366E26665AE70482B890E4101D6B
60E4F3B37ABCA1346DAAE8FDB8DD9C832EFF3E73BA470E2BACE7B8515CB43388
C27AF99FF9322175CF8D4947E6B3846AFF5163E972156847F58A66660EC8A3A6
5FB47C9F637B4CBB4C73B6A080B0CF6FD1E9665E92032540570FFCC747C67C50
822811AADC404BC7ECD1673E8AA6C3A2F1D82F39430B58C29145E2F1B679C46E
94EDC711883F1E4EA84117A54757E8895A40401A26E1437B39A2F65CAADD6E02
D71FA8AF7453668DC613F326A3344F74AD7AC67569AF399385500ABDA5EDD3BA
343CC5EDD4B558467626850E752B9959FEF1454E53E7A3DCBC2255AD8F6AB4FE
894455118A61C58840CB68A925ACCAD75CEACE863D806916228F0614191A1CD5
DC9BAE256018615AA3725834519449B0A88B4F396654E74099C007930ADB1327
DD119BF799FE3B0B223E1EDA04FE2DA7A1C879143E1C33B6C6344F4BA033AD6F
8E88C33DEF1977796B454BAB2494C930F492A518E8198C708A75FFEF8C49C324
A718AB59B889DED521229E741FFE53F98EBE88B0405AD523254FD3FA4BBE96DA
DA1C27C1C979A0DD4E61C3B1F4C4DE01E42F1C4435EECFC02D97994BC8AF5270
E7CB1458D76ED0229C5FFB4A23B8716018F9050970895D51722CDE8F2EA3D947
DFF374D84915D5C5D16463A6FFCD079D1ED416C4347BF831FF0C4ADFB61295DC
4D5785BB0852BF472CFC97EC174491CAF961AB90629F055E75DAA6D9898E8653
5BCF379816CAE46FEA62E7BE8E9B953466E51828172C4DBD0E1BBAD1CE28B5B1
02B3E36403BE80B49A47446A6677FCED438F01D60EB10F478C89528FA337D0D8
88D3FC123C076507ACDAF783A9A6E24ED73BF24B6E0F11C13E532DE5F70B1491
307A6D9A2F2BA5099C8A07762E70BDAA74BA5E2BAB260C1352107EB8A96523D9
4BA3082B99772D585329AB8645C3BBD11D72BA01F95CCF11C6DEBFDAAF7F5C4D
795F99DAE6A8D59462D759001BBEBB59AB0C322EFE02904D82B424649C2FA593
0E23281DECC5AA908E54244566055D418602EEDBE78843300158908F77C0AC75
9562065826D34C38C598D8626BFED7CB672F132E065E2C27932F709935988376
94901EBAEAEC410E2B36575A71EBB8954C3A90EEC264E6115950FC91D0D54999
323D8B4FF8129A8EEC3900A00CCB026E6943BE1728BCD3F6C1BFD503D55A6A7A
6376AF4D646B2F31B1AF935446DCC68233C72AC164BB393DA250B0B423D32887
C680509C862B6F49EAEC995036CF797BC11DD87159241A7503B1FC87023766D2
E1CA46A71DA0AC434AFB2D0C28359EE36A63B5584392FCCAAD696E61EC2B757A
1DC3F0AD50200A15715177C4CE424AF4E484131D7D41397CA16F94ECDAEE6F50
4993ACB7DFDCE53402EA5735B39DD765146BF85A6457A2AEC22A9DD1C21C71B6
250216362D339354391F795EAB160C08136C08B4E4D9B0DD864CF7DDAC5CB67C
C39406C8F712B2D5A78D4A1D0EAF1AAEF7173842216339B40BF0356970D895DF
1F4BB3A9E77D3B4C08F061113877E6DF96CAB4404F3AA0D2CD799A1E1ABEBD08
153F22FE69F59DE85BBBEAD7A81DE32825848FCF97B7D1CB5D8F121EC7175CCC
937A0F9E49F8B27EEF8E1087FF370606241EC1977967D9988DE1196E1195BEC8
A5E1724C1F8C43F22DF8
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: NimbusRomNo9L-ReguItal
%!PS-AdobeFont-1.0: NimbusRomNo9L-ReguItal 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Regular Italic) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Regular) readonly def
/ItalicAngle -15.5 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-ReguItal def
/PaintType 0 def
/WMode 0 def
/FontBBox {-169 -270 1010 924} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E134D4CB5ABCED39AC635
DA001E9934C198A7F9B9ED0028A85E9AE00421DFD8EAA3BB3B4B4CE45D209303
237BD51809FE4D880900B1EEB236ACA87B9FF6EBE6B994A60AF5D67CCC42BD56
77295C346EB4C62BDC1EF22EE07DAAD928DFB73455F091F32408ED6430B97417
683AF27A03718A156E3F6E7B6E4F2E8177503CD82DDBF4557A3CCFF4C858AE7A
F7EFED6CC521A28342436B953E4650B5792BE85EA2F989EB6D986905A61FA38B
96E1BBC830B74469150FB0B598A794FD80D10870084A877273A9502C3456E5EF
74350E6E3BE5863E8BA185EB59FB87B36566AF71200B6ED389D1287D4E925E33
B2383ED05D87D48586E698FBC5D562ED9D8A09EC3EAA1B1F300224AF20C23F26
A2EADC74562571DA84B3914D1D80B127C6FF4706C7046BBB372A0013E0AB94F0
C27946583871D272BF4F20FA84E89D745DE7BBA885CC09BA72E0F530ED4EF7D1
864B3C67007ED98800284235372F0A70C912E21E851AFBF812165B8DF912CD1A
013E271F0B347967876C68AE4C4107EF8AD1F170916210034C66394A9D971B68
FBFC1131E37FC178EB97C1B2A0F573ADD9D7C0BF944E6529734DF8A7EF54485B
A3375CC30E9E328943733CBD352BC15B06C85BFB4A96994291C72A0EAE84FB01
0F1B24D0125FB8C16D60561DF8BB7AA7DDFE9549AFB70C1E89424214609FDE41
9A142892E30F02754FD234CEB3C59A2A04C06BAB7AE40E8FDEC50559B8347684
391C750987802D5452C47C1E0B5F222DE9A0EEAFEE19D796FF375A1E1EF0AEED
1BCAC4F485FCAEE18AEC585D1A9D80F41871DDA45FEF1EAE82C5893118987BEB
4D9E345C27C7419FE65E4853B40537D822E34FF1E0BD2819D21EF607981259E8
9F1040A2D708D7463858AA5381759AC49DF4DDDEB209A278FE60BD2508ACA0F4
6A249A05B652E4C7BF1B676943CDC463B1AFEE36C1C3B9E85BD54EB70431575E
BF28ECC41A6A0A5E89FD2B68A2F70C638789E364846C907E143CF1D3FC1360C1
D342C94322EEC1547E7ADF123582F655B10A77CD82EB3C0FB8C09606DFD022C0
BB2449CFA284AB052240413FEE760A8C80ABA4CBCA22DADA1349ECC4A9950C85
78B6D7B384C4A037A848A335E8D451109CAAE2811E499C038D545584A870538E
2AE9A38C509097D2E55E6C7A52C3C7106FE2658CCCC0E009FCD0D66C0F9656E4
7E98A214318EAB91191B962D6EDBB5B03576BE188F8A87EDCC0E550DB1D88A78
A306ED8D2DC700CB7782113A1C2469DDB654DD3B851D01B563FB3A21150ECB02
E34FB17C3017641863900200F291B2E624482DCAF786C10BEDB739584F60DB12
106932087FF4370D1C25711478FD4AC8E03BE4A2885A935A1CB7E6B2B198EB6F
00A9B4C5CB1FDE6F0DE21DEA2126F3A9076269B99888609B62B7CBA5C6A21609
CB4D90B6068A5235A94489F21B514032F3FBAC45690A84EF3A2C0D17C269633D
AE67C713FEA091BCC7C6AF76A0DF223531C12CDEC349D2325D6FAAC3C1EBA008
0CF4DFCACEE5513EAF3E903BAB38790E8729740D29D27C8018BECD829ACB6C3D
9129E976A242787A0C37B62D3D1BF8537CFCE40CA18283494E800D98DF7E1AFA
EF792660158797BACFBD7CD6FBB41FF7BB607868D480DF6C530C83A874B32A4C
E1F47F0B7609CEC5EE646AE2E2DF81E278A3AB9359A878A64E913E84134B1C53
AF1802803BAF5597570A8C6B0B4A5E0E827FBE0C3CFF9C5CAD1CB5BA1AF1B6A8
D13F6A0D3FC382598F6790F69D1C986A64F25CE29C161D1DFED4E056C49EC385
0D88DBE34BE839D3F2F36EE30695E71BBC1DDCDBC1B006CFE5A032B95CA40F19
FE0EEEAD466FE804591317688C32F948B47DA046070E46E4BA1A3FD355B1DE1D
32145D39243D0590A90F1C4EC2C69A385600773A0ACAE6D25FAA0A36D430519C
2A613E030279B44188897585385A1BD3C350F31F6E61A7345E056E01C1A481E9
45FD890AA23745900DF0B0C182FB0A973DDC9DB6DE7E7596528D2582B82FBA9F
E336EA62CB55BE2301E115BF38D18AE8461F466E2076146451C2AF25E5EBA344
D34F8CDFBC3BF32EBB01BD69C0C8F8C4FCBCE04F3C65EA91889541467D451A5E
A81586D2E91844C22A3CDE0856BD8640D2B9B1844E01CD39ADC11FA69DDC5020
CC3C14EACE61BCE6EC7A9934BE9DF8E2797BB52CA05603870FE7C734D80223EB
23468E44C251858AC5E400BCE56FB10D9B943D15EDC1A7FE1C67406AD33743D4
7698554FAD99A1932A49161F107C736BA68588FA086B7CDF9BCD574185E0BDCF
156DD12B7A5DC720F155BAE2B6F56497363BDCE76C9BEE311CC71A1F5BA79D4C
E2CFB0849479A5B73E9859B60F9CBC0FC3DC9127D153990C6F546538DE875503
1E283C4C9DB0890D067141BC026AC63ACBE70E3D9BD18D5480E344F6E3280C1F
F2567781434C75782C0008DA12FAA766127DB65A9B532809B1951AF23FF68368
5DE3E5D309221F1221A2F5D568015A4D417E9D1A8524803BE21FD28CDDB4DF46
5DB9A8B025BBB49632A004C4D89269E888FBA1E2544DE0BB152A0901F7BCE5AB
60AC1B2610D72BF5C0832AA63EE771FA86C4255200E3730E533349E8F1489D91
F013E82CFB4AAC7661E3E18940FF69B61DD4BE42E6D87D8F7D9B253A101E723D
CE48D82E48819606E978EA55D01878C314A28C92650A286628FE70E07414F411
C092F1DDB6F6D6A38632A7FA88FA8B82A318E262231F0B515EB96D8B80EBF44C
B95368A12024C0BB437E97A0EBB4121AF186A5687549CD60A676FD984F0C50AF
C2F783594DE2DD727985D1D1F0CF0362D02534F7BD45AFFEE4A232E1E78FB4B2
AE464BECF5865CDD3182B7D2196F268DFC05F881CD7EF4387121F72EEB3A9ABF
13F7A9C46C07F961F6E6BED4A1655EDC31C235D20B206326C7E0B7162E2D45F7
EF6BBEDD9A5A3A74BE4EB0759ADDDCD01182219104B22197EA041EB4BD5601CE
B6D079B999B0FFFF2646E94179D30EBDF73A25B991A8B72034F897E415393E6B
62F58F9DC86556254A8A71F70C88A3D3F03838E2F2AE7F5B6C9E8E528A1E982E
5211409BF7A0E4A8D5214D07B149EABF51C85F0C8A7B7BA333DCB084771199CB
1637834749038663FE94C578066DE920F82C8D6C46CA36C01CECA219E2EF410C
F4A5B4ABBB29858F65E937CDE31D67C847719779DE0B31B842EB1662963564B1
A7B40E5DF8F48C433C5CA5E11B6D06C17FCC1069527F86804DA275D8C6F885EA
26AB5B6AC074B7425C2118FE177FD6094EC7065BED4671DD996474504545DD2C
1B775E4CAEAC1DA45C79249DF538F9BE7DF07DA89B3E96228B547ECF895540EF
660C9A7A54C91039E273FE0FD00B499E22B8CBD28813CA527546F0599F0977CF
DFA594116E4FB1CEC55980CB80336AD198CEF5BD22A14C556F08D8BC9DAF2F5D
B42F92904B4D0DA750DFF2A83A30B03BC1DB36E9B48412EC053B76295C62743C
6E640BF62620A76D2C4EF0EF4D5D68E2B50EB8441057292CB8E3306F74A6B738
9F1A8CAFA41289633BA01D275A4878C535AA816050BC229E49B5D231FE5E26BA
C879B6A7E1A6BEADB2CE70ACBC2940E23F8C860EAD0EC4977851FF7A77DB5CDA
FEEC5907086772F4BE1CBA7691480D037E3EB2F1C411E18FFE4860F334822930
44719077552FC38E2903606F89074070C20E6657032FF77585F4A1A8C6DDA310
8450BDF74E5373FCD4127D1F4EAA2AB5E12DC4F2D4F37A3B26398A1D5AD2F84F
0E1339008A361EB5FCF6B017AB3F7C800A81E662D47AACD4AD77FEE78F3D4072
572E95531C63E1E76AA34EE0AC72369A45B7F085A9B20DB623915950B4C87D72
F27B03AF99B582A9DC56945D411176AD1A8848F979F052CE26AFBA4486E7038C
3C3492C914860E06521EC9E805681BFA84BB311DB67D0136E0984ACFF19D2AB6
FD30228AA165B2D50284860A8999BEF98BE5292433CCDCC160B6805F80315BCB
C1B4C0737EBB623F79B3C763CEFFFA4660F955C6F90995E1895A56ACA672B233
D05F4E3D819F2DCB453312073C7EA122F58EA7402EF6A7BBE5FCFB1E1F43E822
EE2721E984E4FFF861E848907BFF0E9A79CF91E2F23F5348B811342DD3A2B352
DF15418E431B65E01EFA9E51AD12185C82FA0BBD27CC958938553D70B02DA2F4
9827CCF0F39BE0C94CAF9E06D1F5E76B58AF101A0AD64320E0217F90916924BE
AA0DA387B012534B078982F2C051BFBC92187B119420B8FC66299B613FA92BD4
3CFFF6D0AE43C637640FDD149783B8D5C20766D3626CD8D71DCD638A3E49FFCA
7473C362341EA39406D73E24E5E04C6E0ED12E15FF74ACF68FDEEA29FF0EAC10
8829820238728C6305754EF0BDCC8B70AFAF80F730A6B5EEDE3F6750055DFD27
AEC3ABC7B173AD562EA95E0C8146B860B8E47A40077DB6A434E5A5976F71873C
11E9D40A2414485EE51C916E20BAD2C45E5773B1E22DADA452F82097ED5DD8B0
0DFB6C20433C4F2155C167D7B1F6342DCC35BEB2EB86AE5AB1D2CE23F32440E2
379E270AD661DCC7CF1FBCDA4786F5B6A729F015270DDF076B0AEAD03AB485F4
3DD669E9F6D78F7F3A39C4F2125AC8AB538565E06699AE5D68759A52096B795D
B2EC708F4737959B2B859737ECA0E6AEEEF942FC33E59A57F4B9CBCCADFF6803
B31EF9A85BAF11F98DF053BCB33841DF300A7B3E985855FE521816004F765317
5F880A97FDEF370B4C22E3952CDCB610F56E7FE04375081A7A4DB1E26FF20C75
007F00EF200564FB5482E70985D276A7A7BEAFA4514F13F8193B0E25A2589E5D
F9D6FAD8C91E85FE9635A0F5DC4890183DD07B316260DAE1B6853B3FAE508B99
B7CF3B97EE414683897A495F88565BA02F043A587AC9523706FAB55BDEF2D9A3
B50D9F5293BB0A960CF633C69D64978FD33DEB0B660C6C18E482FA30A2C2D889
96599333FDAEBAAB30E04E3C78DAB918F9514727A45645740AED1FA5436E30EF
611299182274531AAC836C1A186EEA1CA1B9966C317179E5038E74DD5222327E
343B210933DB3B156F098CF26A8EBCBD073B0FCA30A5BE0E0C991794A16C5308
5047919451EBA65619CFB64D3465DF646EA9D2299BF3A2B09E45796D492BE91D
3E606E4ADF5E314CD2B49EB568216D1B6061F1C75ADFD500C39FD13F78A1EF23
1C7F0B4755D9782C83321D2AB2EF9D85A2F7E48004B2131C69587A79FEC9F9D2
02B823E7CF3C04612C025BF4788E92318E50042565446074D761A1499CD06C2E
12DF11D379FB285F03644EBA9E50C323C797AD73746B5EF0D01606DBB4085CBC
BBE7C78B24F744C06DF07099FC363368C274E0AAC9F838DD5A9D489250189008
F10D3367C657196C2CFFD8EA20EA384D74D11F9273358E7F80EE2D89B281B248
2372B2C20ED895E24A946B868F9AB139E7A21F77BBDA711E73F6CF45F31613A2
4A30023BEA9A238019210AAAE8AE94F744C02BF2E34544BBB19D1B5F87B7A044
5493171CA3A4439C3B8653C05986E9A6CBCE321333A15D91EEFBEDFFC59EDA04
A147FB51227A5AB0C13E5F4DA48D36959C47B0218392F24C93D7F9FC8D64DCE7
A35F2D504F45CAA0E02507034F043B65E1238AC2BB79FE88CB67DF1D266655E2
FF6B267ACD8E1FD4B60841537B6DDCDE002E74BA03A2B15E0529E61DCAC207A7
163341200FE34CEC934F99C14E909440B5457AE7487224AD4EE61D7F5B5320DB
4E6C7F70B76CB486438D247D023647CDF9352A88E98158207EAF44EB9BEB5FF8
54E57B100AA78C4FC2D4E9C449E1475DBC00969FF873875A247E64D4166BFDA1
2BC262DE9CDFC614D7DC1BC569109C6E6EB4883453C36014EF066419924D265A
B8A16663EB8416C1E7BD29FDC20E11094E2852779FC5C0D5DB9D3C8A1CEB0F94
AEB1E311381ACC86D0856C90A91D904C937A1402C55BD1C45D2C5729767507D9
3B8C0D596E109B62420C578D5760BF6A389251D6969B8AF3AD360A8CC37F875A
62966B7A6BA5E64FABE65A37E50D69181187236F793E013429A238307E3A46BF
D486834A752E5C0D5749F67D9E93816E90A4E899E0B75ECB6E933FD29C35779A
47E32C2580275C2798AC4ACE584E9E277FA99FBA99942BD8E7E6DE2AD12A3E30
510D079086FAC4C330DF0BEC00DD4CB7AD3C6AC427ABF6EB125F8024806F9BBA
2EBD2E5D15FE76DE8655EB743C8E74BEC7074248FEACD82D2A9389868FBB2765
D41B24E87AF1282562AF320E71B0C922EFF8B06AFDF50CBD1F3C2FD03DC600B5
A8B4A708B6FAB473BBEAB9A6D02392A26E3F1844520815F28BF79C57641276FB
947D1E3CE6E8CD6D4CF65A1A2D35F4758B53C3B5CB326393C81BFF389E52B65E
3AD73C6084F2122CE60E28555975652CF3CF2A719579A4D2E53DD72EFA0F70F2
119AAEA93CE81AE710B97C20D7DDAA80ED5D26E1350C195FD7463CC2240A878E
90C70362A156E8CE692366E394CE19AE8F49EA484E371053C9A032767CA72D2B
DC2E8A941E9CA66E26C7937665691A55F6A250C13F187B37E345AEF630E76692
2BA7767F9B7B71100513222B78090C62C071DC9AB75B68C5068ACD6E56AAA637
347C54EAB859FB3B96D12176725D24B7CB21A51AAE04D94C38A0E8AA4F02FC33
15D48C2DA78EAC3C4E5CDA05DE803BFF6A4070910421E915EC9E7E0EE3ABC1B0
EC4646DF41DF1610C0F93EA045FBF4480A86E6C1400AE4EF9DEB6D91451C7078
B4D7F35616D8133CE99E05F166F1DECE1E558481D14469D10DF23F3F1E98327D
CE5C4B7A0CCDD237CAE340F24591FDC7D76528AF926E274030335CA6ED8A4FB1
D0A44C81E6ECD888C7E7878A1F962D673EBCE0CAB71ECF82F4F3C33D960F6284
F42C840ABD1CD6DF846F8A3C25D81963A1653A6AAED6566C6FB95A16AAC6F77F
249AB7E9D376E6DF5E800C3BB93408B7DDCB1E241B4D75DC05142B6495D0AD3C
54526CEE7BEBD6B56752DE50D2AC6CFAC75065D1A2CDF2CC1BF4221E5F334934
1D4E6AE7185BF03A94BAEA5F
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: NimbusRomNo9L-Regu
%!PS-AdobeFont-1.0: NimbusRomNo9L-Regu 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Regular) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0.0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-Regu def
/PaintType 0 def
/WMode 0 def
/FontBBox {-168 -281 1000 924} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E152A40E590419249F2E4
C36159F8E54B532468E36965A38646781AB0B7F6A3E851FD10CAA49ADFC1E546
2FD2EC6150DC6E19523050F6148348A561AD8D2E2721EFF8A570CB33460A745B
926C889304C09753C2D78FB0CA95DC6DE5B8C524752C83601E7E9F73DF660674
F05AD83A166DA9BE89F22FEABD4B2665960F6FB5BC32928E1230C212E5D69CEE
0B3311A1738A11747AE263106916D8E95F25B25B4BC6AFB03B79ABB95DDA518B
41A49458111D2A1433C043627EF9460D324FFE22935F4F6DA88B8B91AE95B34E
08408A34EC8EAC3F65B6AE3E3E2524867EE9D29068F81E4372F4470BEEB4D6BE
EE4DF956BECC0CB77F8490117B22B2FB75C938ED0A5E208D88BC38B2AB8B9CFB
F1D53084B6F43DF336481ECA0AA2D5317BC83FC0E1D4DB01D0B7707EEF217E94
A7F985102DED27D8E8B009F7EF6DB91B91E78BFAE7BD688E10B3DC9AC77CDEE8
47AA4DC8EC78241E593D26EC7A60696151A2AE5325D736E99E01BDCBDE69579F
92EEEC224B6757EEDC64A75455BB665DF42A0E4CE7B99BF3E7D66F8FFC8C13F9
D7A1FF7A9D5FF7AC43396779F11C9B008C33A2043D48B61B88B03104B1425F09
675B559CA4302C001EE80D2B739CC0FD1023BF4F1FF9C01E892E59CCA7C26011
B8E0B6D29CC29FC72792FDA5E7D5D88EF98F9DBA960C96534C399C54865EAB86
0FA2E0D6C7C44B553EAC1574D55E7970744D4792FFFBDCE6FB4365BDBC2965BB
2E9EDAD9E0EBF0B620DB415AD98297F5AE83D9C710436657E74D26E83957C745
89834337035A7501803947F6880B70E56A3A404C62D57B849D28804CBE0F5884
435A0E12DCC9BA414ABB732BFBAE237001F557DEA5E972BA0838A3C7C9EB75AA
4A050DA0A529BDFFBF9011C360564FD17A02C18860AF6B86EFD4E2C125686C9A
5E114E95C71FC89A5DE9C589BFE5AC0480CFF716345265D2435EDAE67CFC4801
5BC08E7A48D683ACDB91E05F469C0C8919D73A5D07A1CCB173E30E76680ACB09
02A40A3E11916198BD69F1A26E88330F50692D0D5917E99E7A01B327413E24AA
E98EA484E45897E6AE4D6997B6E8BBF61C9406E916D56985CB2BD297E8ACFC6E
CF2D2281AD84696B7C6CB584BD85CC20BA14ADD3BC3E25DB91124C0ACF22E902
3CFBF04CC40DE331991E9075D22AB5EE0E849B340050E6C417C664A782D05549
DB2EF572F193B1C12B4635C2B358747046DE5BEEAC87B3D62ECDDD442D0D5BE9
323F04F95D06470E7CD2B151061A15CC1027F6F4AB5F7471ADF319AA50F05423
B864964479A2AA2792A5BF8E92703E6C2C337E4C19C71DAF6A5D81BD0FDF6E2F
EA17C3BD241B2BE5142DEBA285B98FA1CC5E64E32A94C5623538EAD5C8185DB5
230B0C36330A4787B95D7AB95609CCBC4899BECC5A1DEFF206520D6F9C1CB56A
3C0ABF9D15DA7739FAB58D988C6AF013B4927E7651E3C81A45D312066D2BFC2B
8BB8C69E55078F36DD098417045D24B06806C95FBF1635CBD660AE045986D682
4F964B21990C9A657131D614CC5ABD9BE6F606226FA3ED1FD3D04E919C9010C2
2EB55191CC4924E34C0EA2AE82D3DEACFC09D88CFBA928D5D432170FBCB19B4C
29CE1851BAEEFEE73149E7BD8C20B7796749FD662131D897EF920655B93EBBAE
2BBD038F21047D0019EC29DC06ED4D34A5E4A2F4C5A85BBDE0A289CFE5908521
ED82B2F9D5CB5D32B93F2CA8FA546DB1A5A2BF31622A00A885E1179E5D7D63E5
A2950ED9ADA8C302401DBF10B71D8253E6F8FA7AC8DD1F4DA7BB92EE841CCB21
1A48AE998ACBF266FEB7DA27CFC0DF14AB47FFCA0BFAF40BD9C5A8652C95246A
640E9625BCB3CB6F2D9B6376843D91DA00229226A37259CFB0AD3BC263B04847
ABB4B3D170C275B9F1AC3156D731198DACE229EBBA62BBF3976782EE4B45DF43
4B01660CFF3F89A17E8D1F0D615CBD7F3E302E4430D8AF79983D51761B5F653A
26842C9832772C15EB82E86734FF9C269B6A0329F2EEE9665495B5991CA19FBD
C6CE9BF59CACD65E0343794EF59D71762377135087FA51722AAC41B5ABF2F6F2
7F6379F8B834F56C2705EEB6BE603469FD69E3164B7210C5F31B1B64C44B61D4
DFCDBD5E715734E737C9AEC087074191606122030AAC762C3ADC5AFECEC8BBFA
221258285A7F461D1073E87926A92508CAC175F0987A3A9598B607955B38FFE1
69AAFE8102DDB9909A1D47D0BF07ABF75A03385FDF6C7CCE8467250DF1DA97A8
83DBEEF75D9A9869D1612D59D7FF4EDA98E456F41F67A7063A2EF9ED5AC30A07
B87D4831E9033E6406E6904C934DDF1025D0C7DC1257A4207783CDAF3688E575
64736CA6775316D92B8142904200DD53397B02197B6FA86ABDCF97ACC1B898DF
8CFB68EB1B58B1722D9984913CFA67666BB174AF131DCBB515F1B16E2B05F820
76631C38774FB9454F35DFEC0D5C540614DD882127AD674DF737129BB809B878
335F49869093D1956B67CDC4829076E0908328E8131D9FCEFBFD625B7348402B
EE59368220EB2EC5788E17A29A339F99A0BE9FC33A702D808AAB91FD490F1EE5
CD5F6824BCF389AA13083B51915495A5A98EAA75BA9DFB5157288201B6D8ED03
E1BDA91AF1E97E58E8FDA3598ADA081CCD1400BCDAF242BBB2714153F62008B3
5157F11930C8756A84FD681880B3CE799AED7F5EACA0D28D6A0F247C07FC508D
83491CE04DFA2AFD66876487792F13685C591E0E2933F73C43D4FF3DE2DAD922
BEAE31D1239719766CD650AF2D9B1753B28B1C5AB49AC0C200FB38A6E3622061
1A604F7E9946B2F474A9CFA2EC28FEC13422167D2F49D7601A570BE03DAAFD89
6177F1F70EADCF7E077FF92CEEE279D1C890B0ACF56291130D4859BD3323A0B7
09F40562D627BE31F7E98BA78C2B52607F5AD63067BF47432AF95D5C2D52F322
CC455711C0147CB76F4723BB02264A6C8B2E30DDBF4C141FCFE9A92971730029
02B322CAE9F3BCC6747D39011DB94742CFADFC9BBA510EDCC40844358B9C6170
5E696EE3C7923C16D5B6A68856A2E0FEAEE135137D6B3318F2492264508F05EB
BE46B06D933F779DD3762F7A5A783A3890579DC734BF90478DF1B3289B644F0F
E75C845866D3C9F193007139398A4A2FAD7A0B984D06EDA697E791D3E8740ADA
1B49CF00C714B377D79253AC6B0536A108FC0AB67D6C6459BD6BC7BD3DE66A11
5B3B9EABF914594C3103771C653C3F7DFB4449DEB0C041F77A3FEA2046E328C1
1B9AB18E397C3B76D2ABC067885B5CEC6149A689194994A690FF0E40EC09EF43
CFE4C05C80C058525D76B03E578ABE923BD936E8B34DEAA74C0DF7A66334C742
685421CE3D57B9784DE4B5CA81DCBE071A7C87B39F7F9713F521697FF5A410F4
21C51ACB5D33BA91C44E47C2EDBDFDFCAAAA05435C172D8F06D85305F4994827
5D5448234426334D812CFCC7FD26617453DB291BB2F6754BC499887247B80849
C0A77BED57231A94FFC6283A2AC55D3DC29229863CCCDBE52AE12428B80AD2B5
757B57A7F549E9BDBDE5FAC50AA0FC880C13F25F9EA9D6A486D00933217DF1A0
B6E764018E2D3BEFD25178DF0837FDF4A9F66BDF64FF40C5FF67879B70282D46
560E249B028CDCD7C5EB8481A60C1456D347C577E5AA72FA4F0E757C98981C77
058FE1D5A7E3BD5F41B72830FF8E800375EBAF361CE665A39072F998EC3D6ADF
6DFE2EB2D22AFEAFC6A39F729E9557505C35E1405C7EF5833CB676DB1C0C1E9B
D75AF56BBD106053978353D268A13FEE0D1DA71827BC04AEB160329B68A2CE58
7608555325191D0E968569CAF99EA4A13F62D4B661895B7CB1149DC7E68F8014
898EFD2472B10CEBB1A42269F50B1AFB4F6385A9A38D3DAD511EF04FD5C1146F
455A258D68ABB0B62662B1F28DBE73E4AD631B6FB53D5392707641742E1F806C
AB0CB6C8025111091F5482426C3F1C4E084953B58F09AC09182EEB72EC4DB030
0955625428127B3DBC58C38D21633B17BCAAF74F37E8A195E0D70BF5C83F775A
7F29246B6DB1B21F0AC69C0AF0ABD9B647C40CB9A31CEF7A08EF370CCDEBB036
8F097B2850D59D2C70AF6906328A1C381E9CD932EF3ED0B873CD7BE2A48735BB
4A751E38332B536CDEA9511431A285354D4157E86EC1BEEE54D45F37AFD8D151
61EA0CE00A340443C20443C6E5E32C3356C1D25CBAF8F71089C3F94EFB702445
F618CFECDC45A8D96D7B83073CE78791C707A975D2C77A9E4B76689F6FC544FD
D4A65861C14EF081758DCF08BF3BDF8C4F3B76185AE27922D871414F7E8131E6
FCA51EA4FEC2A4EAAEEEB2E1C9A5B9886840A2F08D727FA2AEFCBE4AC82DAFEE
F86EB672AE59BE46A004F3145E84D01E1EB4C67950F332048EE9B163F9A5A984
4276F856200CAA40242356A7E44656A9672293E79BCC68E7725DF0CCA67DE6AC
11DF45751A377D1A8084CDF108F2D5390410B66E843F3E9F445EE3FEB863614F
B745A1B35BBE24E44A2731CEBFA7A76657B33491BB8064120C3556E7E93FB428
C637E0CEE89596E2C31214EBF7D91A1A3AA31C369FD8752025C2A954D3D147D7
B7F1A1A556F04A2159E3ADCCCFCABCF0DD42CDC4E708287650172D935887CECC
56BE5768A26E2B6C467E54790062892C27B8088A957F00E0BEB47CD4F7452BC7
089B9F799623A8F02429380D1CED73A031BD4D7C70C1EA4A59E14850D84A9EA9
A6DBDDBBBE33ABB7D22E5704AB1A1F79B934B4710C1332C0D05B459A0E4AE468
09014BEC9A4F0FA8EA5259DB879B3B7E300479CA421E5A963614F4CD898A0171
708C0AF94B47510BDFFE3DC6E12F9ABF4E0DDC239AD820186F1FE3032AEE9A73
D7DCF7722D3CADF7C3C4563F802F8C21C64C220243CFFE1E73A753C7E77E05D8
51E57006A9CD1C75BAA5D8D51197FB6ADA3128EBFE15161A1E4D1AFCCDC7E6D1
A7C1530E2E205455CE083B3B4B63ED91DDCD3FC10789AC6FA67F3BD2E3D3B333
444BEAF07554BCE0AD72E176552EE8672E0AC6E2DE0E5F9094E55F65DD77E826
3B96774427A5E58627242C75E303F4155CA1CAC2A5CFF1F310774D18DFD9C566
58965231411F110FCC1ED63C1CC6A940360422F59F50625FAE9DD08A8BB3C39D
282B791DDE3A547E16A8CCBE3E2F865EE8E446C3691A53B44966DB71B23B0A9C
F1F1FB873365EA1FCACDD36E4DBE4A95ED72104A59134C57CDD6CDF409F82C32
DC422B8E26214670C6B573815A3AA972142C992B73248DBEFBE0E0F59655CD0F
29A9F19B1C412A0B5BFD2BF4004B833D55762A8F4CD9081D31AA562AFE0CB33D
D1E49CBC44FB969E9BBFED7EFD628C0B53F4BC5752147BBE75D0F3876628578D
B99CFE6CCD39359AC7480C14B3DF9FCC294FC992950E4C0FC033FA4E783492DB
FEAE6395F5B6542529352239E5D03D6B0810A8C72A7F13BFAA8782F29EABA9B8
1CA2044814FD32474BF01ECD2D86AC97966D2748B94651C6B2B3CF3DB02BD936
01FC94A1A7E1957D754BBCD1F981E42383AE1671DA98058129A3454140300FF9
0AE6FDF04168ABF2FC5664D0823552497B8F391B6449DDC3F17FA30DB55080D9
B6C7FC6CFD5C157FDA795BF004ABE7300E9299394D143417A82A68DC8EB51B8F
1D2961FDBA02556FB320785FADFE7A39C44E259355E9073401088078B10AEB7E
AB2A70AD3C0A327A90E16092E727CB2BAA0128995EB7C49B0FF17722847C88C9
C0A2FE4804ED676411B1B592DFD4914D53B8EFF347467DF545E945F3E231D1BB
0CF75B2E565CFA592C54A42801A142883EBF015FA811741665208446CAA0AD7F
D946EE45EF3C791B051658EB95929653513BC23A2AEBEAE056BB36132D39A44D
3309A3B18B4BE3185DF2B065FF2F04A7FBDA01C6F91DEC661475905983E84F59
B8F57165B37F41C142AD4D0C57DA93D0027D617FEB2C807C63D2F56C93D6E71B
14F4A9915064E7EE69353131437822B20B5E396F430C501D46E821750FAFBA1C
F306101C7D563C43E4C161AAB16B9DF176051ABB7C78512D6F34A84B9DB66691
259BA46DAD405158B41D78DE4ACD48F80B0D4525A091D1C8991C348E7186369A
6F39DEAE8D919C8307620F64F18D7164BC597A28D5E06E1A1833C74A1F068A3A
A9A515AC5D6B5F8B5A1402C2C4DC011B043066ED02BD5F29999C7A0E3AC55C74
35402D28F2E84D2EE64345B149EC50538677F469C6352DEF8F355245AA68D47A
60537ECEFA041D118A831AE444F711312CCCD8E06297A5263656102794A4250B
09977DA2B47BD27DA0AC845A331FA714905187DE9D26DE3E130ED2ECA88552E3
C5D8BBE0EFCB1137CD28D69C92798E58C0395F6C91AA1CB51F9E01D4030DB380
33832BB94F585F652C1F1CA27ECB4E79111E39A3A8571D54EDA7D7E39BFCCB87
122F41D6F72A757DF99A15AA5610C82FE9B6F9C2CCBC0FF2E710146CB5EA7AB5
1CDB59CFCF6E7C9CB506DA14089ADBF2B4C9DF946069F59F608B8D9973DE7345
6A96D7771A3A2275ADCA69464D94FB0989B98194B2141AD782AE0B77ED328FB3
B96244DFD2475CFCB44CDBCBEC1FE30A7C001EDB362E3E8D2E590CB52A40CC66
F550A64FEB77B1BE50054C2D0F6C6F8A235B5815AD5C54C2C7C5061926D547F7
C468E69EE0F80FB15A485D9BB619214916C852EDB49B80CF000C29BEDB2A138A
DB0E37D689C3A55C94130C7A4AFC739F4739AEE6D7F0F17E613C8EB438586225
7D5F9A75095FBFA7E3B2B839838BB87C04841CDBEE459B73A91E44A40AD22BE2
1B2B2B48FF19ECAAE4EF56058A2CC91FC4FDB39CCAC92D86370D5F973B44B758
1BDED74C9BEF3D01F0FF14BB3DB24ECADECC768773F6E86B3E1FA0288511EB8C
432B4F3BDC36320B4C7BDB024AB440B6ABA270A95C5B052A9B458F3E49B12E74
89FAE3D19FAD2B2047544B528C5220FD1B492AB156863A01696A5985B177ADF8
86E034396ED7711A90B4592F519849EECC61B4FFA86ABF086446AA18D71F35AE
68E1AE4EEF343543AA94AB29F29A950AF028658E6703E340F784C649F65CA60E
BB2461AA63CB1F7A4969B3946A2EAAA1C54F2F501AA172055892C47614A9035E
79B51E7C80FE52EE1275B05D19E6DC95D93914B71382086E96C3BBEC27564A3E
4D7B473606A827BE2D3F3CE87E3E4C73DD80B02AEC078CCEEB60CBA649BF145B
1695F91A18B8B8E0313B154F6B34A894F1EBAEAC18CBD11FBD416BCE4AFD2938
CF0DCED9666EDFBAF85F31B948F48B46E1A5A1E756278D3E7C055F1ED96239EA
45D3AF5AAF2C788569A72F0C6CCCA12416589ADD6AF9847960CEF500FE67D124
2DCA461435767D3FA51DA28BA52310E604C23D313121A755C97653E536AAFBA2
577874822F3AF5C246F537B496CB8EF6A3953E320018A6C449AA51E01C7C2131
89B9E2B235EE9708A172E513F6A769AC3C0F35456C1D2133ADF9E3EB045B407E
286E1DED67ED88788F6DFC6E310E4D5FD835783CFFD9CD68C23111022F71CC9B
DB5AF8291FF21247AD4304AF2E9DC60C5F34CF5787E55D6489751D5E468B4D4A
E9C0F600BAE7809FF7BE910365E9B940FAAF9A887A21D593537A79660C4A103D
C2D1F22DB0765578F118BC8B564F5F35EFF494D893A25D602BE7C692ADD7C415
310472B0825589E9FE859D46854229755E5AD394DBEEDC8A720ED497C4511EA2
14742347DA04CE957E016A4C72A6A1CF1E02A882A57957CF45F4702A1B12C6D0
D4D06D60D9AE1681535061B2CC994D41EF6AC07B567DA70D25CD2703F8C6D559
ED7811962AD08A138D2460A839512CBE905187D9BFDB9BE58DD249FB68BEF9F5
8BBF060C451CDB31E7B97EC597DEDEF433AD7AEC15E519FC42426493DDF53162
36854EED51ED4F06BEDF04B9E42060908252DD2E5516241D7F1ABAA3767FA55A
A7F910B910CE3CFEB62FADE425E897DAE5F56001E2107B84DB6FB7E8CD49837A
29E2390645266166FA392D538E2B2F1FB1F986A5E62D303CF49815779E62C0EC
665B6EA4A51D0B7A3A3ACAFAD4AE8A51341B0180318EA67232E1BF8BB38B4458
CEFD78470A3F7C242639D8BF3827D2ECB1C5FDE8251B5C7BA4C53EF113BBBDCC
14A1D2FA227DF7C12D5C234119A69662416725EE2C58BF09D30DFE3B6B8573DC
514FFBF143C72A73B14666050117C783D9EBA55541517CE5F0C9CBC54BC4CD46
E9CB40AF98C69C87B2D0ED9CA2C6A320A93794C3CDA41B2142A84F7E1A523891
60BF0D879E51846CF45FEEDE24BB2EC6F8545F2022A33F10B4646B9861E6AA7C
EABAAFBC5391D1D3F44555E36FC522A9FEE04A10B484328B5E57542040F9ED47
CA7D927126FAC2706599206F1F3DCDB8D9A34A227DD03662C4BD59998FC527AF
0165D0978DF55078E4CBB61C185C8C105C1CF5E666C5FEFB6BDA6F565874C271
F35D3487A8AD82DEE1B8090791088F2433B0E8C971CB07C66E1B7D1086952122
3C140DD085688DEBC02A6E020EF5101E41C289C854F740240E36858E64403E08
94616BBD9691E64833B16F5BD3554F4904438467C435361B9EE2378B0B236517
8CE4FA00DD64D1841B2FE33F3DF5262A92E98F7A5873F70B931CD89C8751353F
493FE4C272E487E9D0D71B2B06D74B7E46A63E203F6E03A90ED01EDD1A467821
59CD556304B4B10D19E633C26771E2301735A28978B5135B8F28084A586515A7
DFAA157D2569CF9160C071E88D43956A34D0B9E350B841774BC20AAD8A9F8E08
844860A45FF4F28683DB0732EC519458AF4B9ED04114B3B7678BD07DC68D87C0
D72DFE10BA134FD6F15A5A9ACDB24B642E658A96B1C5CBD556BCA9C68867CCAC
10F0606752BC838B9246F1420227229158FDA2929CBDE903701D628D162FA24E
B17C99F0EC3DD8F6B42E4FE3CE1EF37AA6593D85C656D4EEE1B00FF2B085A5F4
A2F4E2CD2A33855E7BD7A1E27816151DDB5C1BC3476F9C3B60D1E6CE7AFFA2C3
D716095DA0E49BC3E64FEFE9C5B1B75F3DA493CBD7A0743DBE14DDE27DF49B87
8B2CF759DCE225D43CB54E86B02573961E5788524551BB2D6BAEAA8C826E992E
708937D9DCBFA2AE1240005E56720FB8688FFECE3EE60FB97E9B4C0A2DA0AB79
B6C4C9C01C278FA8F3AAD3ABA241E755F32D59C5EA43CB3395570020A478F335
841C446B3181A4CFAF641EA75630C0B8E5E1DD26A19CDE40E4F1FF7853021953
663899EDC084619F402DDD1AF0B434291ED2EBD425381AD40640AAA4793B8CDE
2AB6B4F413C000D1C3D844E163BE54E3D1896176E7784FDC4B8B925D6F6ADFD8
98287CD6B00F730A9E07CE0B683092D2866FBF9D7F5BA05BB4711336B15F64D7
6ABA7456AF84581F7BFA215B2B0B1A7C67C3FEA42EB54F22E9A730AB8D4D5C03
5C6247166107D6C1A4FAF9AE46BCF6A6475B41925A54C10F7689C1F0806C014F
8B11CC7B8D1C52D16FB811CEB85D46E935A68FC20BB1A6A879D62FDDDC616ADC
7E9F993528DD1F803DD63D8A9C290103A0D490FD76DAFC93207A276638214467
31629AEFCB7C240AE6875118873186BDA16B44FAC0B9F2FA45089665C7417E29
2EF7995082ACA8795937C0298A3184122E6DA850F1FFF8E8DFF24FFBA06065AB
22476BDA98F5A84278785188372EB7FC46CA3D96BE9DF0E3D47A27CEFB79F004
AF81C8F356BB3EC41CE4CC429B2C2C207309D5039F57A485DAE4401A55A78FED
1C78B632A83BD51755FD2D1747C426EDF382A7BB87D3EA68CAD764A6E9274789
B932899BA29D7F01EDD8B87C1351B5BCB275311964148F193305D9EF18F7479D
E2EF9B2808414AA4695D774B46A3D4194BC7DDED6987F0DD3CA419BC2D3095B5
2497973F54A5C15375E6A8E4C1682BD8B84473B12CD6C815BC25BAA1ABE59A48
F46683AE927088B156AB6499A4DB08DB2A33B5819982A3CC0A2263992E5D2472
1F020FF1B3FF67F4C95D32A50EAE8B4FFEC01D96FBD7D076A6E90E54B431BD0A
06A21FC18543D247B35672FDAB479F8D98FCC88B05D6B067CA22D25F8BC7773C
BE4ECE9B5A4BA50C092F9D792B6929E2C1CEADCD2EE3CD18172D6AB92D62C895
084784161045DFEC08D7A8F91BC11F0241E95F4421CBDA8D0176CCDA89B366F3
C55662A12DC9251EA8854F04CE2C76B6B4BB482FFF09E20DC125548CD91E20B3
F92ED3A68F866994152B40E093CDD503D787A1416AD0FF129DBA675D1239A7FD
2CC98708E04A5AB714B111D8A8FE84D9FFA47F843A6972A781290D136A9B5D69
A31D428F46C5478A8B0406CA423CB281B766B177D60EF103E8C6155B464CE33E
EA95A09C7B64F45856AAA4F80B0C2D3700556F3011B666F4148991C353852B4C
D283018EB513B9ED3512EE7BD1383725052B5BA19ABA1D5BF00773410ED0F7B1
DB49F96AF896F9B09E68528214503E95BA711D82F7CF420622EB34B4E3DD2D6B
D77D42D4F1646CD21FF107338BD4134C8C65B2FBBE4C4D1209DFEFAE449075EE
FDB048D5A30D1827179CF6B4B45C14C9B744BD98DB7B151F18BF75E71B5B6E70
22B99AA55C94130C7A4AFC74472C5DDD24714345E89DB88F02C61C2BAC61E3A1
967F668F6A4F8C660FF93A69F6F9AA110916DE3DEFD7185675405E6E483B8128
1DC11DFF631A52E520AC849C89427823965F9090FDD74BE3B66F615D5CAB6156
69572E82BCF35D79A7AF39D84BF80D7EAED1C12A72CEB48AE2E215B07693A551
0B31F2F70F2EBBC3E4476C5F3C9885BD5B576D6EE4CA6151FAAA3330B738AADC
342595419A851AF73C197866D6E6D7EFC0CCC823107F7BA8F0F9C67FA75D32FE
863B865B88EC70E89A7B24032854B34F5FFF1B2283621D7F3BEEFACF7C07F249
FC058275A863D921A182DC7C205D39E164B2D5CFF784282EF7462564CBD49D18
20E68CC90638FB41EA6562C59C5C28F859D516B562BE6C8DE630BC8264E1A293
5F3463195DE95A253AD84C9B7EB6D77357E5733B4D4C76A47A1335CA1AD3C2B4
51361DC744F66C9B02F0589CC0FEFF6A2759DA45FE05D46494A56D2DDAAEAA1B
5075D535AB33E72BFDCB847408D1CE24CF7FCD2B4AECB69CCD0811185FA00058
93ADDD71F0378DCCFD760F7159438C42FB1CFFCB08B0AA19301D76B7450F200B
0DF7B4DF34233D0713A6DBF2A6FF6B33BD3E063CE3F140506C64D2F5A6F86FFB
A5C6267A2A20B8CC7B4E610BDA85D5E118B83A29004D43E6AA583E8805314300
43A5880931DA86BBFAFA13291C28312DDCB7FFB35DC549F5DC528F6A3183BF16
95FFCA78165621EC8AB15453E3726E32E5C129BFF10F485B8221483C2AD47B0A
CA186EAF9B1E62A3574A9C02A9899C60002606D9346B3F6F0DDB628CE2D48DF0
7F7F5FA40C11AADCAF0F01D275E1EFBA43B4FDA7165837C1CC8F3E692717F109
B9E570703E7CC1E00A85596654238572501D7EBD958D3986BF189636922FFACD
CAAE158E2441F3E029896389831EE0B257B817D62F5FA63C265E94E95EF21ADE
C6A5F224CD3F911B6C7A645C08093CD34DBAE82E720B654E8834304911653925
C7A84981F54318A5781E9563CDB36C19D24C20710E06DF2CF0D98C72B040E769
B03231A30F19CB6F77C3F71D8B32C2B968EF663DB3600CD25D42218AAEA966C1
71E70770ECC26A560A3CF00CF7F2740E69C2C48EAEE34B49A91C2B00083A43E4
E59793BF99E3AF71BA45348B98A4E60ED4C40C1AE5BBC84E86A9F81CEE1C7EBC
9E2D15EAB7D9FBA35B1DAD5C2A9145DCC40F1BF57F4787D82579699F29CCF14B
FA422B5697E77BC76B66E23A1F7864291A3B3F75915B61BB8A5564D25108D190
63171F21009D0B8CD2C1CF7B6CA10E80597CF12059372BFCC3A4DED815F574AE
0A4B8A8D02B4747B0102669CB93FADB692ABA18AEBC87C392AB9CAE36EF4D10F
3B059DDA3C8C771345EEFB47B268DE519C7474A8753EC7884634BA5F2E78E5A3
18BF4AA42649375B491D52E3013E4FE2602E8509B4C7C069F3BB0FF307E0E452
FBD712D9FDCCC6E949EB76BE5F375A2E342F491AC2BBAF5F897076148DA8306D
89442C4E660864C0153D04178B4C68403D4414203F28D1A7CC9C91D02AAEBF56
C7CFD25CCA8C79B951550EA0077DFF8B94C4E615FD8E880AD8A62B6623E18594
51885662727E888203AFB0502A965BA2E97A86B1773B448A8A5B09C2C1F4D792
C1F84EE8339ACA1EC269E51E2B7D35ED0ADECC15D4D9D70FAC38400C232F8208
4F2972CFB0C9CB8EBB09454E47BB19DF7F0434C9599D05F7F39D7B7ACA4E046A
79C0E73591A5F65867FA2E39A02BE99A7A0858D7D2F5805787CB70DF68889423
B02861B0E7D22079CD6B6CB26A2B905FB8E060108486C88A990E5A58D8B53F30
0F292C47E3E309A7170A45FDE2CCCD226894F6F5F94F511E2DC96DAB3A26E4D5
72DB710A9CEB2B1469BD7E95B6C0C4AA77241E833935EF629841738BEFE8F161
E9C3B70800CA19EC2E7C9746CC1C0F80D10BBE6E270356559D6A40177C5FDE03
6B1A969BBD3A7283796DEC7595EB361EBA418800776261BAB953C44887EA0BCD
5FE2F901E0111DA90614FCECDB287FFAD3981149B599B7A744185A793F21AD66
C3058CA4994F6AD3FD3E5A6B83784F525CD9045B7CE03E003C04E822FC78F108
92C88B3F789DCE8A85CDF5BEBEA023FF0098BBC46B846444EFF0B7528B586A5D
BB75B7341F06D8E3EDF5681F106A3C6C9158CB627642C6BB6FAAAD1EA8F78593
B904ED8786AD555EF8263312CE4DC173E20212B08B2C4A0552C55377BDEF37D4
9B03422AA4377D5229936E44410D947D57E2564B96D60F11D98AA8D39165B9A4
DC3F8327384C52F0FC0D9818696077A3CA0E5E9DF6757F80CCD67F1386AF8C4D
3F28A1D94B66AFB38F366C892BC1CEF61DB89EA3280D9F3320A3FA6B16477307
978B7184EF0303F096B8AC079CA3844FDCB80A3F4BBD9216E836B3E1C569AD37
CC6A19C53781CB28F73FE64BF2A68BA821040D76D7CEB3A83EEF9A3DFA30AADA
DCEC7A23562930885266C75986B4653403D2EFD5840A405D3CD72643E2406BF1
57B24AA44B8A2EB58AB65F5B2F5F8BE4F479BB9687E17C209AD1DAA4B9968F63
A4DBB2577D35FA97863739DEFA16ABD0824D0A27D4DE5AB3F4D8A9C63BF6D9BE
D5FD4D6A02822E6BAC8E8DDAC833BEAF6A6CDA7673DFCD596C01D38BD51F4D34
683B6CD09BBFC5702836259B2E153D830278A737BCDAAC86D0B8F1723267A335
1BD9B24B0F76A45E10BAA1F52DEB54DF7A4D88F0F5B153B4E969A96DA884D9AA
98C1A69D5D3E6AB30EBE91F996F0E9C9EBF980848F1C59171EE08CC692283061
877B8DF92884D9B1FFA3D062F591AE295EFE1080EC8FE9609F8237F710D77E2E
60E6DB7E87F6D29938DE74FFF5349C83F7FA121F57894193517FD2B74127E462
6A13B6163E9318F92190A94746E27E7C615B24651DBD97CA5284A961089B8CC4
886307D41FAF883A6CFE9429459EADCEAC84738186E282048E63529DD3AA7333
43EDD935018D616E4BCFD07D16883ACFE1649C6B64969B78AA623E9AD56BC5D0
4524F4739C650A8EF849F321D8DBBBCF97CF15CDB5416C31EAD06301B1024D29
A3146C19FA9B1B6B933AC6BAE28C6816D6F79171BE8A94C858687A7C0B844549
1A9FA36793CDAF2C0BC684811D8ACFD6FFC26D7461111089BCA3A7FEB81F58B2
0B01A33DE66E4A14C5AADA109D57F6F4C59C8E1AE52DA7D48ABF0731455404DD
0AF81C83B9097C0E7F8D23C9851E9F1027B4F17C28938ECEC34D2650571351FA
5058FE6771DB42FC7AC512A2EF6FF2406BDEC0CF6DB56F57A36D9AB4597CA100
EA849934E14225FFBE7A9D5E79FEF48C25DC07A9D5BCA8EE3DBEAC0C5BCBEF68
CF5098D903B359EC07ADFC8590EEEB8D851DE5567F11BF84B5B2BA72C1FF1FC4
3268A567C4A1BCCD5BCCAB67B4FDB3FA818D439FEAB11C0F5BDEAC261B3FA9DF
3589CFCB27311216BFF627FB976CE74D699A172A0321194481FF17713152ED09
E658D229005BC95571448752B8AA5156A7084F764184F03A3939234C9EFF8224
73EF044C41B3F598045D3F49209115258C0CBDB1FCF48B07F486F57E3DC236A8
07E5DB1FB8B204842D6BDD9B6734D51E5504ADA182BFF67F1A2AF55216579B6F
F3BAF7DA5AD1E8B4F0616389D1161DA0DF895157FBFB18C70EEB1725360319CD
3BFE44DA990523133F0C8142A01633BA30CAC7C5A30EBB57CE10BCDFBAFDD8CC
80A8ADBE2C55747D7A37AEB8BBD3A98F0363CBE262CC03900FF5D32BBDDED85F
6A2AEDFFEC800E54F3A38A4E3DCFBE48C8C702586C5F3E93A1DD8C2BC0BC8649
ED2236DFB2DC2D2E49F782DFF0F619E9AF09D8250C2DCB247E48F3199D344146
68ADB8428E67592C832D9BCF8090A77615F00E471DFB75980C4988250D178E57
B9B8A6CCD579A5774DB0989ECAAF73EA2EF5169AD30BA35D198E23D3814CC975
07A88E56C6D0EC46DCBFF165C8E6BC119C8429121DD9C03113B33CF0ECE7D185
4BBD40CAC445EF4DCE196CFA4550D09C81EC698187BB95DEAB692F49E781D9CD
3C6779A35C7245F8ED4FB370DB2F5AEF967BCFA43E3D6D374AC5414CF1145BDD
224C8AD8E0CDC6A1E65C9FCD642B8505BB2A497E140B10BF2654EA88C7334C
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 1500 1500 (robot_control_flow.dvi)
@start /Fa 138[81 6[81 4[40 4[81 1[81 56[48 48 40[{
 TeXBase1Encoding ReEncodeFont }7 145.289 /NimbusRomNo9L-Medi
rf /Fb 235[113 20[{}1 145.289 /CMSY10 rf /Fc 138[52 18[52
98[{ TeXBase1Encoding ReEncodeFont }2 103.778 /NimbusRomNo9L-ReguItal
rf /Fe 143[73 29[89 82[{ TeXBase1Encoding ReEncodeFont }2
145.289 /NimbusRomNo9L-ReguItal rf /Fg 134[73 1[105 73
73 40 57 48 2[73 73 113 40 73 1[40 73 2[65 73 65 73 65
6[89 105 1[137 1[105 1[81 97 3[105 10[97 97 105 1[65
63[{ TeXBase1Encoding ReEncodeFont }30 145.289 /NimbusRomNo9L-Regu
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 1500dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 TeXcolorgray 0 3320 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 0 3320
a 0 3320 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 3320 a 0 3320 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 3320 a 0 3320 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 3320
a 0 3320 a
tx@Dict begin gsave CM STV CP newpath moveto 3.0 neg 0 rmoveto clip
setmatrix end
 0 3320 a 0 3366 4922 3367 v 4922 3320 a
currentpoint grestore moveto
 4922
3320 a 554 163 a
tx@Dict begin  tx@NodeDict begin {7.84593 3.16994 48.0037 24.00185
2.20497 } false /N@M-1-1-1 16 {InitRnode } /NodeScale {} def NewNode
end  end
 554 163 a 64 w @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0  setgray  0.5 true 3.1 neg 3.16994
neg 44.90369 7.84593 .5 Frame  gsave gsave 0.3  setgray currentrgbcolor
grestore gsave 1  setgray currentrgbcolor grestore 1.5  20  3.0 -45.
PtoC tx@PstBlurDict begin BlurShadow end grestore gsave 1  setgray
gsave fill grestore stroke grestore gsave 0.1 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end


@endspecial Fg(Unbound)34 b(State)3850 163 y
tx@Dict begin  tx@NodeDict begin {7.84593 3.16994 40.61867 20.30933
2.20497 } false /N@M-1-1-5 16 {InitRnode } /NodeScale {} def NewNode
end  end
 3850 163
a 64 w @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0  setgray  0.5 true 3.1 neg 3.16994
neg 37.51866 7.84593 .5 Frame  gsave gsave 0.3  setgray currentrgbcolor
grestore gsave 1  setgray currentrgbcolor grestore 1.5  20  3.0 -45.
PtoC tx@PstBlurDict begin BlurShadow end grestore gsave 1  setgray
gsave fill grestore stroke grestore gsave 0.1 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial Fg(Bound)h(State)779
538 y
tx@Dict begin  tx@NodeDict begin {9.5428 4.8668 26.29694 13.14847 2.20497
} false /N@M-1-2-1 16 {InitRnode } /NodeScale {} def NewNode end  end
 779 538 a 914 538 a
tx@Dict begin  tx@NodeDict begin {} false /N@start 14 {/X 6.61136 def
/Y 2.338 def /w 13.14847 def /h 7.2048 def /NodePos { OvalNodePos }
def} /NodeScale {} def NewNode end  end
 914 538 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  0 360 13.14847 CLW 2 div
sub 7.2048 CLW 2 div sub 6.61136 2.338  0 Ellipse closepath  gsave
0.5 1 0.5  setrgbcolor  1. .setopacityalpha  fill  grestore gsave 0.8
SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end


@endspecial Fg(Start)232 1206 y
tx@Dict begin  tx@NodeDict begin {16.36179 3.86993 78.97128 39.48564
2.20497 } false /N@M-1-3-1 16 {InitRnode } /NodeScale {} def NewNode
end  end
 232 1206 a 232 1206
a
tx@Dict begin  tx@NodeDict begin {16.36179 3.86993 78.97128 39.48564
6.24593 } false /N@CRW 16 {InitRnode } /NodeScale {} def NewNode end
 end
 232 1206 a 79 w @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  0. true 3.8 neg 3.86993 neg
75.17128 16.36179 .5 Frame  gsave 0.848 0.75 0.848  setrgbcolor  1.
.setopacityalpha  fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
-162 x Fg(Correlated)h(Random)e(W)-12 b(alk)658 1206
y(Until)37 b(Contact)2517 1206 y
tx@Dict begin  tx@NodeDict begin {16.36179 3.86993 33.27557 16.63779
2.20497 } false /N@M-1-3-3 16 {InitRnode } /NodeScale {} def NewNode
end  end
 2517 1206 a 2517 1206
a
tx@Dict begin  tx@NodeDict begin {16.36179 3.86993 33.27557 16.63779
6.24593 } false /N@avoid 16 {InitRnode } /NodeScale {} def NewNode
end  end
 2517 1206 a 79 w @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  0. true 3.8 neg 3.86993 neg
29.47557 16.36179 .5 Frame  gsave 0.848 0.75 0.848  setrgbcolor  1.
.setopacityalpha  fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
2687 1044 a Fg(A)-11 b(v)m(oid)2596 1206 y(Collision)3621
1206 y
tx@Dict begin  tx@NodeDict begin {13.20605 9.88806 62.66626 31.33313
2.20497 } false /N@M-1-3-5 16 {InitRnode } /NodeScale {} def NewNode
end  end
 3621 1206 a 4002 1206 a
tx@Dict begin  tx@NodeDict begin {} false /N@pu 14 {/X 12.97997 def
/Y 1.659 def /w 15.66656 2 mul def /h 5.77353 2 mul def /NodePos {
DiaNodePos } def} /NodeScale {} def NewNode end  end
 4002 1206 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray   /Lineto /lineto load def
0  setlinejoin false pop .5 15.66656 2 mul 5.77353 2 mul 0 12.97997
1.659 Diamond  gsave 0.848 0.75 0.848  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial Fe(R)4091 1228 y Fc(u)4185 1206
y Fb(\024)43 b Fe(p)4414 1228 y Fc(u)4476 1206 y Fg(?)0
2142 y
tx@Dict begin  tx@NodeDict begin {24.25084 11.75899 101.34015 50.67007
2.20497 } false /N@M-1-4-1 16 {InitRnode } /NodeScale {} def NewNode
end  end
 0 2142 a 582 2142 a
tx@Dict begin  tx@NodeDict begin {} false /N@disc 14 {/X 22.64844 def
/Y 6.24593 def /w 25.33504 2 mul def /h 9.00246 2 mul def /NodePos
{ DiaNodePos } def} /NodeScale {} def NewNode end  end
 582 2142 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray   /Lineto /lineto load def
0  setlinejoin false pop .5 25.33504 2 mul 9.00246 2 mul 0 22.64844
6.24593 Diamond  gsave 0.848 0.75 0.848  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0 
setlinejoin 0  setlinecap stroke  grestore end


@endspecial 678 1980 a Fg(Contact)36 b(with)582 2142
y(Unbound)e(Zone?)3730 2142 y
tx@Dict begin  tx@NodeDict begin {17.8073 3.86993 52.1264 26.0632 2.20497
} false /N@M-1-4-5 16 {InitRnode } /NodeScale {} def NewNode end  end
 3730 2142 a 3730 2142 a
tx@Dict begin  tx@NodeDict begin {17.8073 3.86993 52.1264 26.0632 6.96867
} false /N@stationary 16 {InitRnode } /NodeScale {} def NewNode end
 end

3730 2142 a 79 w @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  0. true 3.8 neg 3.86993 neg
48.3264 17.8073 .5 Frame  gsave 0.848 0.75 0.848  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
3973 1950 a Fg(Stationary)3809 2142 y(Until)j(Contacted)401
2888 y
tx@Dict begin  tx@NodeDict begin {13.20605 9.88806 62.66626 31.33313
2.20497 } false /N@M-1-5-1 16 {InitRnode } /NodeScale {} def NewNode
end  end
 401 2888 a 782 2888 a
tx@Dict begin  tx@NodeDict begin {} false /N@pb 14 {/X 12.97997 def
/Y 1.659 def /w 15.66656 2 mul def /h 5.77353 2 mul def /NodePos {
DiaNodePos } def} /NodeScale {} def NewNode end  end
 782 2888 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray   /Lineto /lineto load def
0  setlinejoin false pop .5 15.66656 2 mul 5.77353 2 mul 0 12.97997
1.659 Diamond  gsave 0.848 0.75 0.848  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial Fe(R)871 2910 y Fc(b)966 2888
y Fb(\024)43 b Fe(p)1195 2910 y Fc(b)1257 2888 y Fg(?)1052
3366 y
tx@Dict begin  tx@NodeDict begin {0.0 0.0 0.0 0.0 2.20497 } false /N@M-1-6-1
16 {InitRnode } /NodeScale {} def NewNode end  end
 1052 3366 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@start
/N@CRW InitNC { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB 4 copy
/y2 ED /x2 ED /y1 ED /x1 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def {/ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{/ArrowPos 0.  def /dArrowPos 1.
1 gt {1.0 1. 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos
mul y1 add ArrowInside pop pop } repeat } ifelse pop pop lineto pop
pop end  } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 4922 3320 a 4922 3320
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@CRW
/N@disc InitNC { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB 4 copy
/y2 ED /x2 ED /y1 ED /x1 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def {/ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{/ArrowPos 0.  def /dArrowPos 1.
1 gt {1.0 1. 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos
mul y1 add ArrowInside pop pop } repeat } ifelse pop pop lineto pop
pop end  } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 4922 3320 a 4922 3320 a
tx@Dict begin  tx@NodeDict begin /t 0.25 def LPut end PutBegin  end
 4922 3320 a 4695 3369 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  0. true 0.8 neg 0.86993 neg
22.5767 5.54593 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial Fg(Contact)4922 3320 y
tx@Dict begin PutEnd  end
 4922
3320 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@disc
/N@avoid InitNC {  tx@Dict begin  /Lineto /lineto load def 0  setlinejoin
false pop end /AngleA 0. def /AngleB -90. def /ArmA 10.0 def /ArmB
10.0 def /ArmTypeA 0 def /ArmTypeB 0 def NCAngle  } if end  gsave 0.8
SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore  grestore end
 4922 3320 a 4922 3320 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 4922 3320
a 4922 3320 a
tx@Dict begin  tx@NodeDict begin /t 0.1 def LPut end PutBegin  end
 4922 3320 a 4922 3320 a
tx@Dict begin { 2.0 tx@Dict /NCLW known { NCLW add } if  8.55397 4.55692
0.06993 NAngle 90 add  Uput exch pop add a PtoC h1 add exch w1 add
exch } PutCoor PutBegin  end
 4922 3320 a 0 0 1
TeXcolorrgb 4833 3367 a Fg(No)p 0 TeXcolorgray 4922 3320
a
tx@Dict begin  PutEnd  end
 4922 3320 a 4922 3320 a
tx@Dict begin PutEnd  end
 4922 3320 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@disc
/N@pb InitNC { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB 4 copy
/y2 ED /x2 ED /y1 ED /x1 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def {/ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{/ArrowPos 0.  def /dArrowPos 1.
1 gt {1.0 1. 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos
mul y1 add ArrowInside pop pop } repeat } ifelse pop pop lineto pop
pop end  } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 4922
3320 a 4922 3320 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 sub } def /ps@rot
{ } def grestore  end
 4922 3320 a 4922 3320 a
tx@Dict begin  tx@NodeDict begin /t 0.1 def LPut end PutBegin  end
 4922 3320
a 4922 3320 a
tx@Dict begin { 5.0 tx@Dict /NCLW known { NCLW add } if  10.18484 4.55692
0.06993 NAngle 90 sub  Uput exch pop add a PtoC h1 add exch w1 add
exch } PutCoor PutBegin  end
 4922 3320 a 0 0 1 TeXcolorrgb 4816 3367
a Fg(Y)-15 b(es)p 0 TeXcolorgray 4922 3320 a
tx@Dict begin  PutEnd  end
 4922 3320
a 4922 3320 a
tx@Dict begin PutEnd  end
 4922 3320 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@pb
/N@avoid InitNC {  tx@Dict begin  /Lineto /lineto load def 0  setlinejoin
false pop end /AngleA 0. def /AngleB -90. def /ArmA 10.0 def /ArmB
10.0 def /ArmTypeA 0 def /ArmTypeB 0 def NCAngle  } if end  gsave 0.8
SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore  grestore end
 4922 3320 a 4922
3320 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 4922 3320 a 4922 3320 a
tx@Dict begin  tx@NodeDict begin /t 0.1 def LPut end PutBegin  end
 4922 3320 a 4922 3320
a
tx@Dict begin { 2.0 tx@Dict /NCLW known { NCLW add } if  8.55397 4.55692
0.06993 NAngle 90 add  Uput exch pop add a PtoC h1 add exch w1 add
exch } PutCoor PutBegin  end
 4922 3320 a 0 0 1 TeXcolorrgb 4833 3367 a Fg(No)p 0
TeXcolorgray 4922 3320 a
tx@Dict begin  PutEnd  end
 4922 3320 a 4922 3320 a
tx@Dict begin PutEnd  end
 4922
3320 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@pb
/N@stationary InitNC {  tx@Dict begin  /Lineto /lineto load def 0 
setlinejoin false pop end /AngleA -90. def /AngleB 0. def /ArmA 10.0
def /ArmB 10.0 def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB -90. def
NCBar  } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0
 setlinejoin 0  setlinecap stroke  grestore  grestore end
 4922 3320 a 4922 3320 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 sub } def /ps@rot
{ } def grestore  end
 4922 3320
a 4922 3320 a
tx@Dict begin  tx@NodeDict begin /t 0.5 def LPut end PutBegin  end
 4922 3320 a 4922 3320 a
tx@Dict begin { 5.0 tx@Dict /NCLW known { NCLW add } if  18.2837 12.44981
1.21794 NAngle 90 sub  Uput exch pop add a PtoC h1 add exch w1 add
exch } PutCoor PutBegin  end
 4922 3320 a 0 0 1
TeXcolorrgb 4816 3273 a Fg(Y)g(es)p 0 TeXcolorgray 4732
3437 a Fa(\(bind\))4922 3320 y
tx@Dict begin  PutEnd  end
 4922 3320 a 4922 3320
a
tx@Dict begin PutEnd  end
 4922 3320 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@stationary
/N@pu InitNC { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB 4 copy
/y2 ED /x2 ED /y1 ED /x1 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def {/ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{/ArrowPos 0.  def /dArrowPos 1.
1 gt {1.0 1. 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos
mul y1 add ArrowInside pop pop } repeat } ifelse pop pop lineto pop
pop end  } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 4922 3320 a 4922 3320 a
tx@Dict begin  tx@NodeDict begin /t 0.25 def LPut end PutBegin  end
 4922
3320 a 4627 3369 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  0. true 0.8 neg 0.86993 neg
29.18466 5.54593 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial
Fg(Contacted)4922 3320 y
tx@Dict begin PutEnd  end
 4922 3320 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@pu
/N@stationary InitNC {  tx@Dict begin  /Lineto /lineto load def 0 
setlinejoin false pop end /AngleA 0. def /AngleB 0. def /ArmA 10.0
def /ArmB 10.0 def /ArmTypeA 0 def /ArmTypeB 0 def NCAngle  } if end
 gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0 
setlinecap stroke  grestore  grestore end
 4922
3320 a 4922 3320 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 4922 3320 a 4922 3320 a
tx@Dict begin  tx@NodeDict begin /t 0.1 def LPut end PutBegin  end
 4922 3320
a 4922 3320 a
tx@Dict begin { 2.0 tx@Dict /NCLW known { NCLW add } if  8.55397 4.55692
0.06993 NAngle 90 add  Uput exch pop add a PtoC h1 add exch w1 add
exch } PutCoor PutBegin  end
 4922 3320 a 0 0 1 TeXcolorrgb 4833 3367
a Fg(No)p 0 TeXcolorgray 4922 3320 a
tx@Dict begin  PutEnd  end
 4922 3320 a 4922
3320 a
tx@Dict begin PutEnd  end
 4922 3320 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@pu
/N@avoid InitNC {  tx@Dict begin  /Lineto /lineto load def 0  setlinejoin
false pop end /AngleA 180. def /AngleB 0. def /ArmA 10.0 def /ArmB
10.0 def /ArmTypeA 0 def /ArmTypeB 0 def NCAngle  } if end  gsave 0.8
SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore  grestore end
 4922 3320 a 4922 3320
a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 4922 3320 a 4922 3320 a
tx@Dict begin  tx@NodeDict begin /t 0.1 def LPut end PutBegin  end
 4922 3320 a 4922 3320 a
tx@Dict begin { 5.0 tx@Dict /NCLW known { NCLW add } if  26.06761 12.44981
1.21794 NAngle 90 add  Uput exch pop add a PtoC h1 add exch w1 add
exch } PutCoor PutBegin  end
 4922
3320 a 0 0 1 TeXcolorrgb 4816 3273 a Fg(Y)g(es)p 0 TeXcolorgray
4651 3437 a Fa(\(unbind\))4922 3320 y
tx@Dict begin  PutEnd  end
 4922 3320 a 4922
3320 a
tx@Dict begin PutEnd  end
 4922 3320 a 4922 3320 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@avoid
/N@CRW InitNC { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB 4 copy
/y2 ED /x2 ED /y1 ED /x1 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def {/ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{/ArrowPos 0.  def /dArrowPos 1.
1 gt {1.0 1. 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos
mul y1 add ArrowInside pop pop } repeat } ifelse pop pop lineto pop
pop end  } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 4922 3320 a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
